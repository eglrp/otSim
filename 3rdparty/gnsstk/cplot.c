/**
\file    cplot.c
\brief   C functions for 2D plotting directly to a compressed bitmap.

\author  Glenn D. MacGougan (GDM)
\date    2008-04-23
\since   2007-12-19

\b "LICENSE INFORMATION" \n
Copyright (c) 2007, refer to 'author' doxygen tags \n
All rights reserved. \n

Redistribution and use in source and binary forms, with or without
modification, are permitted provided the following conditions are met: \n

- Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer. \n
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution. \n
- The name(s) of the contributor(s) may not be used to endorse or promote
products derived from this software without specific prior written
permission. \n

THIS SOFTWARE IS PROVIDED BY THE CONTRIBUTORS ``AS IS'' AND ANY EXPRESS
OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.
*/

#include <stdio.h>  // for FILE*
#include <stdlib.h> // for calloc, malloc, free
#include <string.h> // for strlen, sprintf, strstr, strcmp, and others
#include <ctype.h>  // for isalpha
#include <math.h>
#include <float.h>
#include "cplot.h"

// deal with msvc empry projects
#ifndef WIN32
#ifdef _WIN32
#define WIN32
#endif
#endif

#if defined _MSC_VER && _MSC_VER < 1400
#define _CRT_SECURE_NO_DEPRECATE
#endif

#ifndef _MSC_VER
#define _CRT_SECURE_NO_DEPRECATE
#endif

//#define INTEL_IPPS

#ifdef INTEL_IPPS // the intel performance primitives acceleration libraries
#include <ippcore.h>    
#include <ipps.h>
#include <ippvm.h>
#include <ippdc.h>
// you must call "ippStaticInit();" before using this class! if IPPS is enabled
// In Windows, for static linking you must include ippcore.lib and ipps.lib
// in your project
#endif

#define CPLOT_SIZEOF_BITMAPFILEHEADER (14) //!< True size of disk (one byte packing required).
#define CPLOT_SIZEOF_BITMAPINFOHEADER (40) //!< True size of disk (one byte packing required).

#define CPLOT_RGB_WHITE       { 255, 255, 255, 0 }
#define CPLOT_RGB_BLACK       {   0,   0,   0, 0 }
#define CPLOT_RGB_BLUE        { 255,   0,   0, 0 }
#define CPLOT_RGB_GREEN       {   0, 128,   0, 0 }
#define CPLOT_RGB_CYAN        { 255, 255,   0, 0 }
#define CPLOT_RGB_RED         {   0,   0, 255, 0 }
#define CPLOT_RGB_INDIANRED   {   0,   0, 128, 0 }
#define CPLOT_RGB_YELLOW      {   0, 255, 255, 0 }
#define CPLOT_RGB_LIMEGREEN   {   0, 255,   0, 0 }
#define CPLOT_RGB_DARKBLUE    { 128,  64,   0, 0 }
#define CPLOT_RGB_BABYBLUE    { 255, 128,   0, 0 }
#define CPLOT_RGB_PAISLYBLUE  { 192, 128,   0, 0 }
#define CPLOT_RGB_LIGHTPURPLE { 255,   0, 128, 0 }
#define CPLOT_RGB_PURPLE      { 255,   0, 128, 0 }
#define CPLOT_RGB_DARKPURPLE  { 128,   0,  64, 0 }
#define CPLOT_RGB_PINK        { 255, 128, 255, 0 }
#define CPLOT_RGB_GREYPURPLE  { 192, 128, 128, 0 }
#define CPLOT_RGB_BROWN       {  64,  64, 128, 0 }
#define CPLOT_RGB_GREY        { 128, 128, 128, 0 }
#define CPLOT_RGB_LIGHTGREY   { 192, 192, 192, 0 }
#define CPLOT_RGB_MAGENTA     { 128,   0, 128, 0 }
#define CPLOT_RGB_ORANGE      {   0, 128, 255, 0 }

#define CPLOT_LARGEFONT        (14)  //!< The width and height of CPLOT's large font.
#define CPLOT_LARGEFONT_NBYTES (196) //!< The number of bytes in a large font letter.
#define CPLOT_SMALLFONT_HGT    (7)  //!< The heigHt of CPLOT's small font.
#define CPLOT_SMALLFONT_WIDTH  (6)  //!< The width of CPLOT's small font.
#define CPLOT_SMALLFONT_NBYTES (42) //!< The number of bytes in a small font letter.

#define CPLOT_PIXELS_PER_CM    (38) //!< The number of pixels per centimeter.

#define CPLOT_POINT_SIZE       (5)  //!< The width/height for a point [pixels].
#define CPLOT_LARGEPOINT_SIZE  (8)  //!< The width/height for a large point [pixels].

#define CPLOT_DEFAULT_PLOT_WIDTH_CM  (15) //!< The default plot width [cm].
#define CPLOT_DEFAULT_PLOT_HEIGHT_CM (13) //!< The default plot height [cm].


typedef unsigned char  byte;


/*
const CPLOT_structRGB kRGB_White       = CPLOT_RGB_WHITE;
const CPLOT_structRGB kRGB_Black       = CPLOT_RGB_BLACK;
const CPLOT_structRGB kRGB_Blue        = CPLOT_RGB_BLUE;
const CPLOT_structRGB kRGB_Green       = CPLOT_RGB_GREEN;
const CPLOT_structRGB kRGB_Cyan        = CPLOT_RGB_CYAN;
const CPLOT_structRGB kRGB_Red         = CPLOT_RGB_RED;
const CPLOT_structRGB kRGB_IndianRed   = CPLOT_RGB_INDIANRED;
const CPLOT_structRGB kRGB_Yellow      = CPLOT_RGB_YELLOW;
const CPLOT_structRGB kRGB_LimeGreen   = CPLOT_RGB_LIMEGREEN;
const CPLOT_structRGB kRGB_DarkBlue    = CPLOT_RGB_DARKBLUE;
const CPLOT_structRGB kRGB_BabyBlue    = CPLOT_RGB_BABYBLUE;
const CPLOT_structRGB kRGB_PaislyBlue  = CPLOT_RGB_PAISLYBLUE;
const CPLOT_structRGB kRGB_LightPurple = CPLOT_RGB_LIGHTPURPLE;
const CPLOT_structRGB kRGB_Purple      = CPLOT_RGB_PURPLE;
const CPLOT_structRGB kRGB_DarkPurple  = CPLOT_RGB_DARKPURPLE;
const CPLOT_structRGB kRGB_Pink        = CPLOT_RGB_PINK;
const CPLOT_structRGB kRGB_GreyPurple  = CPLOT_RGB_GREYPURPLE;
const CPLOT_structRGB kRGB_Brown       = CPLOT_RGB_BROWN;
const CPLOT_structRGB kRGB_Grey        = CPLOT_RGB_GREY;
const CPLOT_structRGB kRGB_LightGrey   = CPLOT_RGB_LIGHTGREY;
const CPLOT_structRGB kRGB_Magenta     = CPLOT_RGB_MAGENTA;
const CPLOT_structRGB kRGB_Orange      = CPLOT_RGB_ORANGE;
*/

const CPLOT_structColorTable CPLOT_DefaultColorTable = {
	CPLOT_RGB_WHITE,
	CPLOT_RGB_BLACK,
	CPLOT_RGB_BLUE,
	CPLOT_RGB_GREEN,
	CPLOT_RGB_PURPLE,
	CPLOT_RGB_MAGENTA,
	CPLOT_RGB_DARKBLUE,
	CPLOT_RGB_INDIANRED,
	CPLOT_RGB_BABYBLUE,
	CPLOT_RGB_PAISLYBLUE,
	CPLOT_RGB_LIGHTPURPLE,
	CPLOT_RGB_DARKPURPLE,
	CPLOT_RGB_GREYPURPLE,
	CPLOT_RGB_BROWN,
	CPLOT_RGB_RED,
	CPLOT_RGB_PINK,
	CPLOT_RGB_YELLOW,
	CPLOT_RGB_ORANGE,
	CPLOT_RGB_CYAN,
	CPLOT_RGB_LIMEGREEN,
	CPLOT_RGB_GREY,
	CPLOT_RGB_LIGHTGREY,
};





const byte CPLOT_Point[CPLOT_POINT_SIZE][CPLOT_POINT_SIZE] =
{ { 0,0,1,0,0 },
{ 0,1,1,1,0 },
{ 1,1,1,1,1 },
{ 0,1,1,1,0 },
{ 0,0,1,0,0 }, };

const byte CPLOT_LargePoint[CPLOT_LARGEPOINT_SIZE][CPLOT_LARGEPOINT_SIZE] =
{ { 0,0,1,1,0,0 },
{ 0,1,1,1,1,0 },
{ 1,1,1,1,1,1 },
{ 1,1,1,1,1,1 },
{ 0,1,1,1,1,0 },
{ 0,0,1,1,0,0 }, };


const byte CPLOT_LARGEFONT_sigma[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //11
{
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,1,1,1,1,1,1,1,1,1 },
	{ 0,0,1,1,1,1,1,1,1,1,1,1,1,1 },
	{ 0,1,1,1,0,0,0,0,1,1,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,1,1,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,1,1,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,1,1,0,0,0 },
	{ 0,0,1,1,0,0,0,0,1,1,1,0,0,0 },
	{ 0,0,0,1,1,1,1,1,1,1,0,0,0,0 },
	{ 0,0,0,0,1,1,1,1,1,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_A[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //11
{
	{ 0,0,0,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,1,1,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,1,1,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,1,1,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,1,1,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,1,1,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,1,1,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_B[CPLOT_LARGEFONT][CPLOT_LARGEFONT] =  //11
{
	{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,1,1,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_C[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //11
{
	{ 0,0,0,1,1,1,1,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,1,1,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,1,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,1,1,1,0,0,0,0,0 },
	{ 0,1,1,1,1,1,1,1,0,0,0,0,0,0 },
	{ 0,0,0,1,1,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_D[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //11
{
	{ 1,1,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,1,1,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,1,1,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};



const byte CPLOT_LARGEFONT_E[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //11
{
	{ 1,1,1,1,1,1,1,1,1,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,1,1,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,1,1,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,1,1,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_F[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //11
{
	{ 1,1,1,1,1,1,1,1,1,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_G[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //11
{
	{ 0,0,0,1,1,1,1,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,1,1,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,1,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 0,1,1,0,0,0,1,1,1,0,0,0,0,0 },
	{ 0,1,1,1,1,1,1,1,0,0,0,0,0,0 },
	{ 0,0,0,1,1,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};



const byte CPLOT_LARGEFONT_H[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //11
{
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,1,1,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_I[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //3
{
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_J[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
	{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,1,0,0,1,1,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_K[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //11
{
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,1,1,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,1,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,1,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,1,1,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,1,1,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,1,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_L[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_M[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //13
{
	{ 1,1,1,0,0,0,0,0,1,1,1,0,0,0 },
	{ 1,1,1,0,0,0,0,0,1,1,1,0,0,0 },
	{ 1,1,1,1,0,0,0,1,1,1,1,0,0,0 },
	{ 1,1,1,1,0,0,0,1,1,1,1,0,0,0 },
	{ 1,1,0,1,1,0,1,1,0,1,1,0,0,0 },
	{ 1,1,0,1,1,0,1,1,0,1,1,0,0,0 },
	{ 1,1,0,1,1,0,1,1,0,1,1,0,0,0 },
	{ 1,1,0,0,1,1,1,0,0,1,1,0,0,0 },
	{ 1,1,0,0,1,1,1,0,0,1,1,0,0,0 },
	{ 1,1,0,0,1,1,1,0,0,1,1,0,0,0 },
	{ 1,1,0,0,0,1,0,0,0,1,1,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_N[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //11
{
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,1,0,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,1,1,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,1,1,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,0,1,1,0,0,1,1,0,0,0,0,0 },
	{ 1,1,0,1,1,1,0,1,1,0,0,0,0,0 },
	{ 1,1,0,0,1,1,0,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,1,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_O[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //12
{
	{ 0,0,0,1,1,1,1,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,1,1,1,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,1,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,1,1,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,1,1,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,1,1,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,1,0,0,0,0 },
	{ 0,1,1,0,0,0,0,1,1,0,0,0,0,0 },
	{ 0,1,1,1,1,1,1,1,1,0,0,0,0,0 },
	{ 0,0,0,1,1,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};



const byte CPLOT_LARGEFONT_P[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //10
{
	{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,1,1,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,1,1,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,1,1,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_Q[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //12
{
	{ 0,0,0,1,1,1,1,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,1,1,1,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,1,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,1,1,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,1,1,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,1,1,0,0,0,0 },
	{ 1,1,0,0,1,1,0,0,1,1,0,0,0,0 },
	{ 0,1,1,0,0,1,1,1,1,0,0,0,0,0 },
	{ 0,1,1,1,1,1,1,1,1,0,0,0,0,0 },
	{ 0,0,0,1,1,1,0,1,1,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,1,1,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_R[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //11
{
	{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,1,1,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,1,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_S[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //10
{
	{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,1,1,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,1,1,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,1,1,1,1,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,1,1,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,1,1,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_T[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //10
{
	{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_U[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //10
{
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 0,1,1,0,0,0,1,1,1,0,0,0,0,0 },
	{ 0,1,1,1,1,1,1,1,0,0,0,0,0,0 },
	{ 0,0,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_V[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,1,1,0,0,0,0,0 },
	{ 0,1,1,0,0,0,1,1,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,1,1,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,1,1,0,0,0,0,0,0 },
	{ 0,0,1,1,0,1,1,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,1,1,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_W[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //14
{
	{ 1,1,0,0,0,1,1,1,0,0,0,1,1,0 },
	{ 1,1,0,0,0,1,1,1,0,0,0,1,1,0 },
	{ 1,1,1,0,0,1,1,1,0,0,1,1,1,0 },
	{ 0,1,1,0,1,1,0,1,1,0,1,1,0,0 },
	{ 0,1,1,0,1,1,0,1,1,0,1,1,0,0 },
	{ 0,1,1,0,1,1,0,1,1,0,1,1,0,0 },
	{ 0,1,1,0,1,1,0,1,1,0,1,1,0,0 },
	{ 0,1,1,0,1,0,0,0,1,0,1,1,0,0 },
	{ 0,0,1,1,1,0,0,0,1,1,1,0,0,0 },
	{ 0,0,1,1,1,0,0,0,1,1,1,0,0,0 },
	{ 0,0,1,1,1,0,0,0,1,1,1,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_X[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //10
{
	{ 1,1,0,0,0,0,1,1,0,0,0,0,0,0 },
	{ 1,1,1,0,0,1,1,1,0,0,0,0,0,0 },
	{ 0,1,1,0,0,1,1,0,0,0,0,0,0,0 },
	{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,1,0,0,1,1,1,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,1,1,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_Y[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
	{ 1,1,0,0,0,0,1,1,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,1,1,0,0,0,0,0,0 },
	{ 0,1,1,0,0,1,1,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,1,1,0,0,0,0,0,0,0 },
	{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_Z[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
	{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
	{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_a[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //8
{
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,1,1,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,1,1,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,0,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_b[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 1,1,1,0,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 1,1,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_c[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_d[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
	{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,1,1,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,1,0,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,1,0,1,1,1,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_e[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_f[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //7
{
	{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_g[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,1,1,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,1,0,1,1,1,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 0,1,1,1,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_h[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,1,1,1,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,1,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_i[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //4
{
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_j[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //5
{
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_k[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //8
{
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,1,1,0,0,0,0,0,0,0,0 },
	{ 1,1,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,1,1,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_l[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //4
{
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_m[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //12
{
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,1,1,0,0,1,1,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,1,1,1,0,0,0,0 },
	{ 1,1,0,0,1,1,0,0,1,1,0,0,0,0 },
	{ 1,1,0,0,1,1,0,0,1,1,0,0,0,0 },
	{ 1,1,0,0,1,1,0,0,1,1,0,0,0,0 },
	{ 1,1,0,0,1,1,0,0,1,1,0,0,0,0 },
	{ 1,1,0,0,1,1,0,0,1,1,0,0,0,0 },
	{ 1,1,0,0,1,1,0,0,1,1,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_n[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,1,1,1,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,1,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_o[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 1,1,1,0,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,1,0,1,1,1,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_p[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 1,1,1,0,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,1,0,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 1,1,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_q[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,1,1,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,1,0,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,1,0,1,1,1,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_r[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //6
{
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_s[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //7
{
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,1,1,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_t[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //6
{
	{ 0,0,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_u[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 0,1,1,1,0,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_v[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //8
{
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 0,1,1,0,1,1,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_w[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //12
{
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,0,0,0,1,1,0,0,0 },
	{ 1,1,0,0,1,1,1,0,0,1,1,0,0,0 },
	{ 0,1,1,0,1,1,1,0,1,1,0,0,0,0 },
	{ 0,1,1,0,1,0,1,0,1,1,0,0,0,0 },
	{ 0,1,1,0,1,0,1,0,1,1,0,0,0,0 },
	{ 0,0,1,1,1,0,1,1,1,0,0,0,0,0 },
	{ 0,0,1,1,1,0,1,1,1,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,1,1,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_x[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //7
{
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,1,1,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,1,1,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,1,1,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_y[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //8
{
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 0,1,1,0,1,1,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,1,1,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,1,1,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_z[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //8
{
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_tilda[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //10
{
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,0,0,0,1,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
	{ 1,0,0,0,1,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_exclamation[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //4
{
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_at[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //12
{
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,1,1,1,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,1,1,0,0,0,0 },
	{ 0,1,0,0,1,1,0,1,1,0,1,0,0,0 },
	{ 0,1,0,1,1,1,1,1,1,0,1,0,0,0 },
	{ 1,0,1,1,0,0,0,1,1,0,1,0,0,0 },
	{ 1,0,1,1,0,0,0,1,1,0,1,0,0,0 },
	{ 1,0,1,1,0,0,0,1,1,0,1,0,0,0 },
	{ 1,0,1,1,1,1,1,1,1,1,0,0,0,0 },
	{ 1,0,0,1,1,0,1,1,1,0,0,0,0,0 },
	{ 0,1,0,0,0,0,0,0,0,0,1,0,0,0 },
	{ 0,0,1,0,0,0,0,0,0,1,0,0,0,0 },
	{ 0,0,0,1,1,1,1,1,1,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_hash[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
	{ 0,0,1,1,0,1,1,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,1,1,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 0,1,1,0,1,1,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,1,1,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_dollarsign[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //10
{
	{ 0,0,0,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 1,1,0,1,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,1,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,1,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,1,0,1,1,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_percent[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //14
{
	{ 0,1,1,1,0,0,0,0,1,1,0,0,0,0 },
	{ 1,1,0,1,1,0,0,1,1,0,0,0,0,0 },
	{ 1,1,0,1,1,0,0,1,1,0,0,0,0,0 },
	{ 1,1,0,1,1,0,1,1,0,0,0,0,0,0 },
	{ 0,1,1,1,0,0,1,1,0,0,0,0,0,0 },
	{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,1,1,0,1,1,1,0,0,0 },
	{ 0,0,0,0,1,1,0,1,1,0,1,1,0,0 },
	{ 0,0,0,0,1,1,0,1,1,0,1,1,0,0 },
	{ 0,0,0,1,1,0,0,1,1,0,1,1,0,0 },
	{ 0,0,0,1,1,0,0,0,1,1,1,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_raiseto[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //10
{
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,1,1,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,1,1,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,1,1,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_andsign[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //11
{
	{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,1,1,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,1,1,0,0,0,0,0,0,0 },
	{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,1,1,0,1,1,0,0,0,0,0 },
	{ 1,1,0,0,1,1,1,1,1,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,1,1,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,1,1,1,0,0,0,0 },
	{ 0,1,1,1,1,1,0,0,1,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_star[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //8
{
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,0,1,0,1,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,1,0,1,0,1,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_leftbracket[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //5
{
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_rightbracket[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //5
{
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_dash[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //5
{
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_underscore[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_plus[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //10
{
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_equals[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //10
{
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,1,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_leftcurly[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //6
{
	{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_rightcurly[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //6
{
	{ 1,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_vert[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //5
{
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_leftsquare[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //5
{
	{ 1,1,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_rightsquare[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //5
{
	{ 0,1,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_backslash[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //6
{
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_forwardslash[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //6
{
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_semicolon[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //4
{
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_colon[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //4
{
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_singlequote[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //4
{
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_comma[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //4
{
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_point[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //4
{
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};



const byte CPLOT_LARGEFONT_doublequote[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //8
{
	{ 0,1,1,0,1,1,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,1,1,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,1,1,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_lessthan[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,1,1,1,0,0,0,0,0,0,0 },
	{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,1,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_morethan[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,1,1,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_LARGEFONT_questionmark[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //9
{
	{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,1,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};



const byte CPLOT_LARGEFONT_One[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //7
{
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 1,1,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 1,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_Two[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //8
{
	{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_Three[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //8
{
	{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,1,0,0,1,1,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_Four[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //8
{
	{ 0,0,0,0,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,1,0,1,1,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,1,1,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,1,1,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_Five[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //8
{
	{ 0,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,1,0,0,1,1,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_Six[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //8
{
	{ 0,0,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,1,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_Seven[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //8
{
	{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_Eight[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //8
{
	{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_Nine[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //8
{
	{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,1,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};

const byte CPLOT_LARGEFONT_Zero[CPLOT_LARGEFONT][CPLOT_LARGEFONT] = //8
{
	{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 1,1,1,0,1,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,0,0,0,1,1,0,0,0,0,0,0,0 },
	{ 1,1,1,0,1,1,1,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,1,0,0,0,0,0,0,0,0 },
	{ 0,0,1,1,1,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
};


const byte CPLOT_SMALLFONT_A[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,1,0,1,0,0 },
{ 0,1,0,1,0,0 },
{ 0,1,1,1,0,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 }, };

const byte CPLOT_SMALLFONT_B[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 1,1,1,1,0,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 1,1,1,1,0,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 1,1,1,1,0,0 }, };

const byte CPLOT_SMALLFONT_C[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,1,1,1,0,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,0,0 },
{ 1,0,0,0,0,0 },
{ 1,0,0,0,0,0 },
{ 1,0,0,0,1,0 },
{ 0,1,1,1,0,0 }, };

const byte CPLOT_SMALLFONT_D[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 1,1,1,1,0,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 1,1,1,1,0,0 }, };

const byte CPLOT_SMALLFONT_E[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 1,1,1,1,1,0 },
{ 1,0,0,0,0,0 },
{ 1,0,0,0,0,0 },
{ 1,1,1,1,0,0 },
{ 1,0,0,0,0,0 },
{ 1,0,0,0,0,0 },
{ 1,1,1,1,1,0 }, };

const byte CPLOT_SMALLFONT_F[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 1,1,1,1,1,0 },
{ 1,0,0,0,0,0 },
{ 1,0,0,0,0,0 },
{ 1,1,1,1,0,0 },
{ 1,0,0,0,0,0 },
{ 1,0,0,0,0,0 },
{ 1,0,0,0,0,0 }, };

const byte CPLOT_SMALLFONT_G[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,1,1,1,0,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,0,0 },
{ 1,0,1,1,1,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 0,1,1,1,0,0 }, };

const byte CPLOT_SMALLFONT_H[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 1,1,1,1,1,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 }, };


const byte CPLOT_SMALLFONT_I[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 1,1,1,1,1,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 1,1,1,1,1,0 }, };

const byte CPLOT_SMALLFONT_J[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,1,1,1,1,0 },
{ 0,0,0,1,0,0 },
{ 0,0,0,1,0,0 },
{ 0,0,0,1,0,0 },
{ 0,0,0,1,0,0 },
{ 1,0,0,1,0,0 },
{ 0,1,1,0,0,0 }, };

const byte CPLOT_SMALLFONT_K[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 1,0,0,1,0,0 },
{ 1,0,0,1,0,0 },
{ 1,0,1,0,0,0 },
{ 1,1,0,0,0,0 },
{ 1,1,0,0,0,0 },
{ 1,0,1,0,0,0 },
{ 1,0,0,1,0,0 }, };

const byte CPLOT_SMALLFONT_L[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 1,0,0,0,0,0 },
{ 1,0,0,0,0,0 },
{ 1,0,0,0,0,0 },
{ 1,0,0,0,0,0 },
{ 1,0,0,0,0,0 },
{ 1,0,0,0,0,0 },
{ 1,1,1,1,1,0 }, };

const byte CPLOT_SMALLFONT_M[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 1,0,0,0,1,0 },
{ 1,1,0,1,1,0 },
{ 1,0,1,0,1,0 },
{ 1,0,1,0,1,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 }, };

const byte CPLOT_SMALLFONT_N[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 1,0,0,0,1,0 },
{ 1,1,0,0,1,0 },
{ 1,1,1,0,1,0 },
{ 1,0,1,0,1,0 },
{ 1,0,0,1,1,0 },
{ 1,0,0,1,1,0 },
{ 1,0,0,0,1,0 }, };

const byte CPLOT_SMALLFONT_O[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,1,1,1,0,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 0,1,1,1,0,0 }, };

const byte CPLOT_SMALLFONT_P[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 1,1,1,1,0,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 1,1,1,1,0,0 },
{ 1,0,0,0,0,0 },
{ 1,0,0,0,0,0 },
{ 1,0,0,0,0,0 }, };

const byte CPLOT_SMALLFONT_Q[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,1,1,1,0,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 1,0,1,0,1,0 },
{ 1,0,0,1,0,0 },
{ 0,1,1,0,1,0 }, };

const byte CPLOT_SMALLFONT_R[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 1,1,1,0,0,0 },
{ 1,0,0,1,0,0 },
{ 1,0,0,1,0,0 },
{ 1,1,1,0,0,0 },
{ 1,0,1,0,0,0 },
{ 1,0,0,1,0,0 },
{ 1,0,0,1,0,0 }, };

const byte CPLOT_SMALLFONT_S[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,1,1,1,0,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,0,0 },
{ 0,1,1,1,0,0 },
{ 0,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 0,1,1,1,0,0 }, };

const byte CPLOT_SMALLFONT_T[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 1,1,1,1,1,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 }, };

const byte CPLOT_SMALLFONT_U[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 0,1,1,1,0,0 }, };

const byte CPLOT_SMALLFONT_V[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 0,1,0,1,0,0 },
{ 0,1,0,1,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 }, };

const byte CPLOT_SMALLFONT_W[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 1,0,1,0,1,0 },
{ 1,0,1,0,1,0 },
{ 1,0,1,0,1,0 },
{ 0,1,0,1,0,0 }, };

const byte CPLOT_SMALLFONT_X[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 1,0,0,0,1,0 },
{ 0,1,0,1,0,0 },
{ 0,1,0,1,0,0 },
{ 0,0,1,0,0,0 },
{ 0,1,0,1,0,0 },
{ 0,1,0,1,0,0 },
{ 1,0,0,0,1,0 }, };

const byte CPLOT_SMALLFONT_Y[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 1,0,0,0,1,0 },
{ 0,1,0,1,0,0 },
{ 0,1,0,1,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 }, };

const byte CPLOT_SMALLFONT_Z[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 1,1,1,1,1,0 },
{ 0,0,0,1,0,0 },
{ 0,0,0,1,0,0 },
{ 0,0,1,0,0,0 },
{ 0,1,0,0,0,0 },
{ 0,1,0,0,0,0 },
{ 1,1,1,1,1,0 }, };

const byte CPLOT_SMALLFONT_a[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 },
{ 0,1,1,1,1,0 },
{ 0,0,0,0,1,0 },
{ 0,1,1,1,1,0 },
{ 1,0,0,0,1,0 },
{ 0,1,1,1,1,0 }, };

const byte CPLOT_SMALLFONT_b[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 1,0,0,0,0,0 },
{ 1,0,0,0,0,0 },
{ 1,0,0,0,0,0 },
{ 1,1,1,1,0,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 1,1,1,1,0,0 }, };

const byte CPLOT_SMALLFONT_c[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 },
{ 0,1,1,1,0,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,0,0 },
{ 1,0,0,0,1,0 },
{ 0,1,1,1,0,0 }, };

const byte CPLOT_SMALLFONT_d[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,0,0,1,0 },
{ 0,0,0,0,1,0 },
{ 0,0,0,0,1,0 },
{ 0,1,1,1,1,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 0,1,1,1,1,0 }, };

const byte CPLOT_SMALLFONT_e[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 },
{ 0,1,1,1,0,0 },
{ 1,0,0,0,1,0 },
{ 1,1,1,1,0,0 },
{ 1,0,0,0,0,0 },
{ 0,1,1,1,0,0 }, };

const byte CPLOT_SMALLFONT_f[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,1,0,0,0 },
{ 0,1,0,0,0,0 },
{ 0,1,0,0,0,0 },
{ 1,1,1,1,0,0 },
{ 0,1,0,0,0,0 },
{ 0,1,0,0,0,0 },
{ 0,1,0,0,0,0 }, };

const byte CPLOT_SMALLFONT_g[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 },
{ 0,0,1,1,1,0 },
{ 0,1,0,0,1,0 },
{ 0,1,1,1,1,0 },
{ 0,0,0,0,1,0 },
{ 0,0,1,1,0,0 }, };

const byte CPLOT_SMALLFONT_h[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 1,0,0,0,0,0 },
{ 1,0,0,0,0,0 },
{ 1,0,0,0,0,0 },
{ 1,1,1,1,0,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 }, };

const byte CPLOT_SMALLFONT_i[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,0,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,0,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 }, };

const byte CPLOT_SMALLFONT_j[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,0,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,0,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 1,0,1,0,0,0 },
{ 0,1,0,0,0,0 }, };

const byte CPLOT_SMALLFONT_k[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,0,0,0,0 },
{ 1,0,0,0,0,0 },
{ 1,0,0,0,0,0 },
{ 1,0,1,0,0,0 },
{ 1,1,0,0,0,0 },
{ 1,1,0,0,0,0 },
{ 1,0,1,1,0,0 }, };

const byte CPLOT_SMALLFONT_l[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 }, };

const byte CPLOT_SMALLFONT_m[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 },
{ 1,1,1,1,0,0 },
{ 1,0,1,0,1,0 },
{ 1,0,1,0,1,0 },
{ 1,0,1,0,1,0 },
{ 1,0,1,0,1,0 }, };

const byte CPLOT_SMALLFONT_n[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 },
{ 1,1,1,1,0,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 }, };

const byte CPLOT_SMALLFONT_o[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 },
{ 0,1,1,1,0,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 0,1,1,1,0,0 }, };

const byte CPLOT_SMALLFONT_p[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,0,0,0,0 },
{ 1,1,1,0,0,0 },
{ 1,0,0,1,0,0 },
{ 1,0,0,1,0,0 },
{ 1,1,1,0,0,0 },
{ 1,0,0,0,0,0 },
{ 1,0,0,0,0,0 }, };

const byte CPLOT_SMALLFONT_q[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,0,0,0,0 },
{ 0,0,1,1,1,0 },
{ 0,1,0,0,1,0 },
{ 0,1,0,0,1,0 },
{ 0,0,1,1,1,0 },
{ 0,0,0,0,1,0 },
{ 0,0,0,0,1,0 }, };

const byte CPLOT_SMALLFONT_r[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 },
{ 1,0,1,1,0,0 },
{ 0,1,0,0,0,0 },
{ 0,1,0,0,0,0 },
{ 0,1,0,0,0,0 },
{ 0,1,0,0,0,0 }, };

const byte CPLOT_SMALLFONT_s[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 },
{ 0,0,1,1,1,0 },
{ 0,1,0,0,0,0 },
{ 0,1,1,1,1,0 },
{ 0,0,0,0,1,0 },
{ 0,1,1,1,0,0 }, };

const byte CPLOT_SMALLFONT_t[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 1,1,1,1,1,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 }, };

const byte CPLOT_SMALLFONT_u[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 0,1,1,1,0,0 }, };

const byte CPLOT_SMALLFONT_v[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 0,1,0,1,0,0 },
{ 0,0,1,0,0,0 }, };

const byte CPLOT_SMALLFONT_w[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 },
{ 1,0,1,0,1,0 },
{ 1,0,1,0,1,0 },
{ 1,0,1,0,1,0 },
{ 0,1,0,1,0,0 }, };

const byte CPLOT_SMALLFONT_x[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 },
{ 1,0,0,0,1,0 },
{ 0,1,0,1,0,0 },
{ 0,0,1,0,0,0 },
{ 0,1,0,1,0,0 },
{ 1,0,0,0,1,0 }, };

const byte CPLOT_SMALLFONT_y[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 },
{ 1,0,0,0,1,0 },
{ 0,1,0,1,0,0 },
{ 0,0,1,0,0,0 },
{ 0,1,0,0,0,0 },
{ 1,0,0,0,0,0 }, };

const byte CPLOT_SMALLFONT_z[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 },
{ 1,1,1,1,0,0 },
{ 0,0,1,0,0,0 },
{ 0,1,0,0,0,0 },
{ 1,1,1,1,1,0 }, };

const byte CPLOT_SMALLFONT_colon[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,0,0,0,0 },
{ 0,0,1,1,0,0 },
{ 0,0,1,1,0,0 },
{ 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 },
{ 0,0,1,1,0,0 },
{ 0,0,1,1,0,0 }, };

const byte CPLOT_SMALLFONT_backslash[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 1,0,0,0,0,0 },
{ 0,1,0,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,0,1,0,0 },
{ 0,0,0,0,1,0 },
{ 0,0,0,0,0,1 }, };

const byte CPLOT_SMALLFONT_forwardslash[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,0,0,0,1 },
{ 0,0,0,0,1,0 },
{ 0,0,0,1,0,0 },
{ 0,0,1,0,0,0 },
{ 0,1,1,0,0,0 },
{ 0,1,0,0,0,0 },
{ 1,0,0,0,0,0 }, };

const byte CPLOT_SMALLFONT_percent[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,0,0,0,0 },
{ 1,1,0,0,1,0 },
{ 1,1,0,0,1,0 },
{ 0,0,0,1,0,0 },
{ 0,0,1,0,0,0 },
{ 0,1,0,1,1,0 },
{ 1,0,0,1,1,0 }, };

const byte CPLOT_SMALLFONT_raiseto[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,1,0,0,0 },
{ 0,1,0,1,0,0 },
{ 1,0,0,0,1,0 },
{ 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 }, };

const byte CPLOT_SMALLFONT_dollarsign[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,1,1,1,0,0 },
{ 1,0,1,0,1,0 },
{ 1,0,1,0,0,0 },
{ 0,1,1,1,0,0 },
{ 0,0,1,0,1,0 },
{ 1,0,1,0,1,0 },
{ 0,1,1,1,0,0 }, };

const byte CPLOT_SMALLFONT_andsign[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,1,1,0,0,0 },
{ 1,0,0,1,0,0 },
{ 1,0,0,1,0,0 },
{ 0,1,1,0,0,0 },
{ 1,0,1,0,1,0 },
{ 1,0,0,1,0,0 },
{ 0,1,1,0,1,0 }, };

const byte CPLOT_SMALLFONT_star[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,0,0,0,0 },
{ 1,0,1,0,1,0 },
{ 0,1,1,1,0,0 },
{ 0,0,1,0,0,0 },
{ 0,1,0,1,0,0 },
{ 1,0,0,0,1,0 },
{ 0,0,0,0,0,0 }, };

const byte CPLOT_SMALLFONT_leftbracket[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,1,0,0,0 },
{ 0,1,0,0,0,0 },
{ 1,0,0,0,0,0 },
{ 1,0,0,0,0,0 },
{ 1,0,0,0,0,0 },
{ 0,1,0,0,0,0 },
{ 0,0,1,0,0,0 }, };

const byte CPLOT_SMALLFONT_rightbracket[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,1,0,0,0 },
{ 0,0,0,1,0,0 },
{ 0,0,0,0,1,0 },
{ 0,0,0,0,1,0 },
{ 0,0,0,0,1,0 },
{ 0,0,0,1,0,0 },
{ 0,0,1,0,0,0 }, };

const byte CPLOT_SMALLFONT_leftsquare[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 1,1,1,0,0,0 },
{ 1,0,0,0,0,0 },
{ 1,0,0,0,0,0 },
{ 1,0,0,0,0,0 },
{ 1,0,0,0,0,0 },
{ 1,0,0,0,0,0 },
{ 1,1,1,0,0,0 }, };

const byte CPLOT_SMALLFONT_rightsquare[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,1,1,1,0 },
{ 0,0,0,0,1,0 },
{ 0,0,0,0,1,0 },
{ 0,0,0,0,1,0 },
{ 0,0,0,0,1,0 },
{ 0,0,0,0,1,0 },
{ 0,0,1,1,1,0 }, };

const byte CPLOT_SMALLFONT_dash[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 },
{ 1,1,1,1,1,0 },
{ 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 }, };

const byte CPLOT_SMALLFONT_equals[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 },
{ 1,1,1,1,1,0 },
{ 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 },
{ 1,1,1,1,1,0 },
{ 0,0,0,0,0,0 }, };

const byte CPLOT_SMALLFONT_plus[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 1,1,1,1,1,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 }, };

const byte CPLOT_SMALLFONT_semicolon[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,0,0,0,0 },
{ 0,1,1,0,0,0 },
{ 0,1,1,0,0,0 },
{ 0,0,0,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,1,0,0,0,0 },
{ 1,0,0,0,0,0 }, };

const byte CPLOT_SMALLFONT_singlequote[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 }, };

const byte CPLOT_SMALLFONT_doublequote[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,1,0,1,0,0 },
{ 0,1,0,1,0,0 },
{ 0,1,0,1,0,0 },
{ 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 },

{ 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 }, };

const byte CPLOT_SMALLFONT_lessthan[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,0,0,1,0 },
{ 0,0,0,1,0,0 },
{ 0,0,1,0,0,0 },
{ 0,1,0,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,0,1,0,0 },
{ 0,0,0,0,1,0 }, };

const byte CPLOT_SMALLFONT_morethan[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 1,0,0,0,0,0 },
{ 0,1,0,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,0,1,0,0 },
{ 0,0,1,0,0,0 },
{ 0,1,0,0,0,0 },
{ 1,0,0,0,0,0 }, };

const byte CPLOT_SMALLFONT_comma[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,1,0,0,0,0 },
{ 1,0,0,0,0,0 }, };

const byte CPLOT_SMALLFONT_point[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 },
{ 0,0,1,1,0,0 },
{ 0,0,1,1,0,0 }, };

const byte CPLOT_SMALLFONT_exclamation[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,1,1,0,0 },
{ 0,0,1,1,0,0 },
{ 0,0,1,1,0,0 },
{ 0,0,1,1,0,0 },
{ 0,0,0,0,0,0 },
{ 0,0,1,1,0,0 },
{ 0,0,1,1,0,0 }, };


const byte CPLOT_SMALLFONT_vert[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 }, };

const byte CPLOT_SMALLFONT_tilda[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 },
{ 0,1,1,0,0,0 },
{ 1,0,1,0,1,0 },
{ 0,0,0,1,1,0 },
{ 0,0,0,0,0,0 },
{ 0,0,0,0,0,0 }, };


const byte CPLOT_SMALLFONT_Zero[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,1,1,1,0,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,1,1,0 },
{ 1,0,1,0,1,0 },
{ 1,1,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 0,1,1,1,0,0 } };

const byte CPLOT_SMALLFONT_One[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,1,0,0,0 },
{ 0,1,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,1,1,1,0,0 } };

const byte CPLOT_SMALLFONT_Two[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,1,1,1,0,0 },
{ 1,0,0,0,1,0 },
{ 0,0,0,0,1,0 },
{ 0,0,0,1,0,0 },
{ 0,0,1,0,0,0 },
{ 0,1,0,0,0,0 },
{ 1,1,1,1,1,0 } };

const byte CPLOT_SMALLFONT_Three[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 1,1,1,1,1,0 },
{ 0,0,0,1,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,0,1,0,0 },
{ 0,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 0,1,1,1,0,0 } };

const byte CPLOT_SMALLFONT_Four[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,0,1,0,0 },
{ 0,0,1,1,0,0 },
{ 0,1,0,1,0,0 },
{ 1,0,0,1,0,0 },
{ 1,1,1,1,1,0 },
{ 0,0,0,1,0,0 },
{ 0,0,0,1,0,0 } };

const byte CPLOT_SMALLFONT_Five[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 1,1,1,1,1,0 },
{ 1,0,0,0,0,0 },
{ 1,1,1,1,0,0 },
{ 0,0,0,0,1,0 },
{ 0,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 0,1,1,1,0,0 } };

const byte CPLOT_SMALLFONT_Six[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,0,1,1,0,0 },
{ 0,1,0,0,0,0 },
{ 1,0,0,0,0,0 },
{ 1,1,1,1,0,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 0,1,1,1,0,0 } };

const byte CPLOT_SMALLFONT_Seven[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 1,1,1,1,1,0 },
{ 0,0,0,0,1,0 },
{ 0,0,0,1,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 },
{ 0,0,1,0,0,0 } };

const byte CPLOT_SMALLFONT_Eight[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,1,1,1,0,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 0,1,1,1,0,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 0,1,1,1,0,0 } };

const byte CPLOT_SMALLFONT_Nine[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH] =
{ { 0,1,1,1,0,0 },
{ 1,0,0,0,1,0 },
{ 1,0,0,0,1,0 },
{ 0,1,1,1,1,0 },
{ 0,0,0,0,1,0 },
{ 0,0,0,1,0,0 },
{ 0,1,1,0,0,0 } };




BOOL CPLOT_BYTE_MTX_Init(CPLOT_structByteMatrix *M)
{
	if (!M)
		return FALSE;

	M->ncols = 0;
	M->nrows = 0;
	M->data = NULL;

	return TRUE;
}

BOOL CPLOT_BYTE_MTX_isNull(const CPLOT_structByteMatrix *M)
{
	if (!M)
		return TRUE;

	if (M->data == NULL)
		return TRUE;

	return FALSE;
}

/// zero the entire matrix
BOOL CPLOT_BYTE_MTX_Zero(CPLOT_structByteMatrix *dst)
{
	unsigned i = 0;

	if (CPLOT_BYTE_MTX_isNull(dst))
		return FALSE;

	for (i = 0; i < dst->nrows; i++)
	{
#ifdef INTEL_IPPS    
		if (ippsZero_8u((Ipp8u*)(dst->data[i]), dst->ncols) != ippStsNoErr)
			return FALSE;
#else
		memset(&(dst->data[i]), 0, dst->ncols);
#endif
	}
	return TRUE;
}

BOOL CPLOT_BYTE_MTX_Free(CPLOT_structByteMatrix *M)
{
	unsigned i = 0;

	if (!M)
		return FALSE;

	if (M->data == NULL)
	{
		M->nrows = 0;
		M->ncols = 0;
		return TRUE;
	}

	// free the data
	for (i = 0; i < M->nrows; i++)
	{
#ifdef INTEL_IPPS
		ippsFree(M->data[i]);
#else
		free(M->data[i]);
#endif
	}

	// free the array of pointers
	free(M->data);

	M->nrows = 0;
	M->ncols = 0;
	M->data = NULL;

	return TRUE;
}


BOOL CPLOT_BYTE_MTX_calloc(CPLOT_structByteMatrix *M, const unsigned nrows, const unsigned ncols)
{
	unsigned i = 0;

	// invalid call
	if (nrows == 0 || ncols == 0)
		return FALSE;
	if (!M)
		return FALSE;

	// Check if the matrix is already the right size and type.
	if (M->nrows > 0 && M->ncols > 0)
	{
		if (M->nrows == nrows && M->ncols == ncols)
		{
			// already the right size and type
			if (!CPLOT_BYTE_MTX_Zero(M))
				return FALSE;

			return TRUE;
		}
	}

	// check if we still need to deallocate memory
	if (M->data != NULL)
	{
		// free the data
		if (!CPLOT_BYTE_MTX_Free(M))
			return FALSE;
	}

	M->nrows = 0;
	M->ncols = ncols;

	// allocate the column array
	M->data = (byte**)malloc(nrows * sizeof(byte*));
	if (!M->data)
		return FALSE;

	// for each column allocate the rows
	for (i = 0; i < nrows; i++)
	{
#ifdef INTEL_IPPS  
		M->data[i] = ippsMalloc_8u(ncols);
		if (!(M->data[i]))
		{
			// this is most likely to occur if allocating more memory than available
			CPLOT_BYTE_MTX_Free(M);
			return FALSE;
		}
		if (ippsZero_8u((Ipp8u*)(M->data[i]), ncols) != ippStsNoErr)
			return FALSE;
#else
		M->data[i] = (byte*)calloc(ncols, sizeof(byte));
		if (!M->data[i])
		{
			// this is most likely to occur if allocating more memory than available
			CPLOT_BYTE_MTX_Free(M);
			return FALSE;
		}
#endif
		M->nrows++;
	}

	return TRUE;
}

/// fills the matrix with the given value
BOOL CPLOT_BYTE_MTX_Fill(CPLOT_structByteMatrix *dst, const byte value)
{
	unsigned i = 0;

	if (CPLOT_BYTE_MTX_isNull(dst))
		return FALSE;

	for (i = 0; i < dst->nrows; i++)
	{
#ifdef INTEL_IPPS        
		if (ippsSet_8u((Ipp8u)(value), (Ipp8u*)(dst->data[i]), dst->ncols) != ippStsNoErr)
			return FALSE;
#else
		memset(dst->data[i], value, dst->ncols);
#endif
	}
	return TRUE;
}

BOOL CPLOT_PlotOptionsInit(CPLOT_structPlotOptions *Opt)
{
	if (!Opt)
		return FALSE;
	memset(Opt, 0, sizeof(CPLOT_structPlotOptions));
	Opt->y_label_right_scale_factor = 1.0;
	Opt->RightYLabelColor = CPLOT_BLACK;
	Opt->numberOfSeries = 1;
	Opt->plotLabelOnRight = TRUE;
	Opt->endOfWarmupEpoch = -DBL_MAX;
	Opt->PlotSize_Width_cm = CPLOT_DEFAULT_PLOT_WIDTH_CM;  // cm
	Opt->PlotSize_Height_cm = CPLOT_DEFAULT_PLOT_HEIGHT_CM; // cm
	return TRUE;
}

BOOL CPLOT_Init(CPLOT* P)
{
	int rem = 0;
	if (!P)
		return FALSE;

	P->mIsAxesDrawn = FALSE;
	P->mSeriesIndex = 0;
	P->mFootNoteIndex = 0;

	P->mStatsValueHeight = 15;
	P->mYLabelAllowance = 106;
	P->mRightYLabelAllowance = 80;
	P->mTitleAllowance = 50;
	P->mXLabelAllowance = 56;

	P->mImage.Height = CPLOT_DEFAULT_PLOT_HEIGHT_CM * CPLOT_PIXELS_PER_CM;
	P->mImage.Width = CPLOT_DEFAULT_PLOT_WIDTH_CM  * CPLOT_PIXELS_PER_CM;

	// The width must be evely divisible by four
	rem = P->mImage.Width % 4;
	P->mImage.Width += rem;


	P->mAxes.StartX = 100;
	P->mAxes.StartY = 40;
	P->mAxes.FinishX = 530;
	P->mAxes.FinishY = 440;
	P->mAxes.Width = P->mAxes.FinishX - P->mAxes.StartX;
	P->mAxes.Height = P->mAxes.FinishY - P->mAxes.StartY;
	P->mAxes.TickDashInPixels = 4;

	// pointer to special color table if any
	P->mColorTable = NULL;

	// this is the default color order
	P->mDefaultColorTable = CPLOT_DefaultColorTable;

	P->mData.xtickstart = 0.0;
	P->mData.xtickend = 0.0;
	P->mData.xticksize = 0.0;
	P->mData.ytickstart = 0.0;
	P->mData.ytickend = 0.0;
	P->mData.yticksize = 0.0;
	P->mData.RangeX = 0.0;
	P->mData.RangeY = 0.0;
	P->mData.OnePercentRangeX = 0.0;
	P->mData.OnePercentRangeY = 0.0;
	P->mData.ScaleX = 0.0;
	P->mData.ScaleY = 0.0;
	P->mData.MinX = 0.0;
	P->mData.MaxX = 0.0;
	P->mData.MinY = 0.0;
	P->mData.MaxY = 0.0;

	P->mLabelWidth = 80; //kSmallFontWidth*mStatsValueHeight;  80*8/32 must be evely divisible

	memset(&(P->mOptions), 0, sizeof(CPLOT_structPlotOptions));
	P->mOptions.y_label_right_scale_factor = 1.0;
	P->mOptions.RightYLabelColor = CPLOT_BLACK;
	P->mOptions.numberOfSeries = 1;
	P->mOptions.plotLabelOnRight = TRUE;
	P->mOptions.endOfWarmupEpoch = -DBL_MAX;
	P->mOptions.PlotSize_Width_cm = 19;  // cm
	P->mOptions.PlotSize_Height_cm = 14; // cm

	if (!CPLOT_BYTE_MTX_Init(&(P->mPlotData)))
		return FALSE;
	if (!CPLOT_BYTE_MTX_calloc(&(P->mPlotData), P->mImage.Height, P->mImage.Width))
		return FALSE;

	return TRUE;
}


BOOL CPLOT_SetPlottingOptions(CPLOT *P, CPLOT_structPlotOptions Options)
{
	if (!P)
		return FALSE;

	P->mOptions = Options;
	return TRUE;
}


BOOL CPLOT_DrawLine(
	CPLOT *P,
	const int x,
	const int y,
	const int to_x,
	const int to_y,
	const CPLOT_enumColor color
)
{
	int row = 0,
		row_last = 0,
		halfway = 0,
		col = 0;

	double m = 0.0,
		b = 0.0;

	if (!P)
		return FALSE;

	if (x >= P->mImage.Width || to_x >= P->mImage.Width)
		return TRUE;
	if (y >= P->mImage.Height || to_y >= P->mImage.Height)
		return TRUE;

	if (to_x - x == 0) // vertical line
	{
		if (y < to_y)
		{
			for (row = y; row <= to_y; row++)
			{
				P->mPlotData.data[row][x] = color;
			}
		}
		else
		{
			for (row = to_y; row <= y; row++)
			{
				P->mPlotData.data[row][x] = color;
			}
		}
		return TRUE;
	}

	if (to_x > x)
	{
		m = (double)(to_y - y) / (double)(to_x - x);
		b = y - m*x;

		col = x;
		row_last = (int)(m*col + b);
		for (col = x; col <= to_x; col++)
		{
			row = (int)(m*col + b);

			halfway = abs(row_last - row) / 2;
			while (abs(row_last - row) > 1) // must draw a vertical line
			{
				if (row_last > row)
					row_last--;
				else
					row_last++;

				// draw vertical halfway up col-1 and halfway up col
				if (abs(row_last - row) > halfway)
					P->mPlotData.data[row_last][col - 1] = color;
				else
					P->mPlotData.data[row_last][col] = color;
			}

			P->mPlotData.data[row][col] = color;
			row_last = row;
		}
	}
	else
	{
		m = (double)(y - to_y) / (double)(x - to_x);
		b = y - m*x;

		col = to_x;
		row_last = (int)(m*col + b);
		for (col = to_x; col <= x; col++)
		{
			row = (int)(m*col + b);

			halfway = abs(row_last - row) / 2;
			while (abs(row_last - row) > 1) // must draw a vertical line
			{
				if (row_last > row)
					row_last--;
				else
					row_last++;

				// draw vertical halfway up col-1 and halfway up col
				if (abs(row_last - row) > halfway)
					P->mPlotData.data[row_last][col - 1] = color;
				else
					P->mPlotData.data[row_last][col] = color;
			}

			P->mPlotData.data[row][col] = color;
			row_last = row;
		}
	}
	return TRUE;
}


BOOL CPLOT_DrawDashedLine(
	CPLOT *P,
	const int x,
	const int y,
	const int to_x,
	const int to_y,
	const int kDashSize,
	const CPLOT_enumColor color)
{
	int row = 0,
		row_last = 0,
		halfway = 0,
		col = 0,
		dash = 0;

	double m = 0.0,
		b = 0.0;

	if (!P)
		return FALSE;

	if (x >= P->mImage.Width || to_x >= P->mImage.Width)
		return TRUE;
	if (y >= P->mImage.Height || to_y >= P->mImage.Height)
		return TRUE;


	// y = mx + b
	if (to_x - x == 0) // m = 0
	{
		for (row = y; row <= to_y; row++)
		{
			if (dash < kDashSize)
				P->mPlotData.data[row][x] = color;

			dash++;
			if (dash == kDashSize * 2)
				dash = 0;
		}
		return TRUE;
	}

	if (to_x > x)
	{
		dash = 0;
		m = (double)(to_y - y) / (double)(to_x - x);
		b = y - m*x;

		col = x;
		row_last = (int)(m*col + b);
		for (col = x; col <= to_x; col++)
		{
			row = (int)(m*col + b);

			halfway = abs(row_last - row) / 2;
			while (abs(row_last - row) > 1) // must draw a vertical line
			{
				if (row_last > row)
					row_last--;
				else
					row_last++;

				// draw vertical halfway up col-1 and halfway up col
				if (abs(row_last - row) > halfway)
				{
					if (dash < kDashSize)
						P->mPlotData.data[row_last][col - 1] = color;
				}
				else
				{
					if (dash < kDashSize)
						P->mPlotData.data[row_last][col] = color;
				}

				dash++;
				if (dash == kDashSize * 2)
					dash = 0;

			}

			if (dash < kDashSize)
				P->mPlotData.data[row][col] = color;

			dash++;
			if (dash == kDashSize * 2)
				dash = 0;
		}
	}
	else
	{
		dash = 0;
		m = (double)(y - to_y) / (double)(x - to_x);
		b = y - m*x;

		col = to_x;
		row_last = (int)(m*col + b);
		for (col = to_x; col <= x; col++)
		{
			row = (int)(m*col + b);

			halfway = abs(row_last - row) / 2;
			while (abs(row_last - row) > 1) // must draw a vertical line
			{
				if (row_last > row)
					row_last--;
				else
					row_last++;

				// draw vertical halfway up col-1 and halfway up col
				if (abs(row_last - row) > halfway)
				{
					if (dash < kDashSize)
						P->mPlotData.data[row_last][col - 1] = color;
				}
				else
				{
					if (dash < kDashSize)
						P->mPlotData.data[row_last][col] = color;
				}
				dash++;
				if (dash == kDashSize * 2)
					dash = 0;
			}

			if (dash < kDashSize)
				P->mPlotData.data[row][col] = color;

			dash++;
			if (dash == kDashSize * 2)
				dash = 0;


			row_last = row;
		}
	}

	return TRUE;
}




int CPLOT_DrawSmallLetter(
	CPLOT *P,
	const char Letter,
	const int x,
	const int y,
	BOOL isRotatedLeft,
	const CPLOT_enumColor color
)
{
	const int klH = CPLOT_SMALLFONT_HGT;   // letter height
	const int klW = CPLOT_SMALLFONT_WIDTH; // letter width

	int row = 0;
	int col = 0;

	byte rotatedleft[CPLOT_SMALLFONT_WIDTH][CPLOT_SMALLFONT_HGT];
	byte temp[CPLOT_SMALLFONT_HGT][CPLOT_SMALLFONT_WIDTH];

	if (!P)
		return FALSE;

	if (y < klH)
		return 0;

	if (x + klW >= P->mImage.Width)
		return 0;

	memset(&rotatedleft, 0, CPLOT_SMALLFONT_WIDTH*CPLOT_SMALLFONT_HGT);
	memset(&temp, 0, CPLOT_SMALLFONT_WIDTH*CPLOT_SMALLFONT_HGT);

	switch (Letter)
	{
	case 'A':  memcpy(&temp, CPLOT_SMALLFONT_A, CPLOT_SMALLFONT_NBYTES); break;
	case 'B':  memcpy(&temp, CPLOT_SMALLFONT_B, CPLOT_SMALLFONT_NBYTES); break;
	case 'C':  memcpy(&temp, CPLOT_SMALLFONT_C, CPLOT_SMALLFONT_NBYTES); break;
	case 'D':  memcpy(&temp, CPLOT_SMALLFONT_D, CPLOT_SMALLFONT_NBYTES); break;
	case 'E':  memcpy(&temp, CPLOT_SMALLFONT_E, CPLOT_SMALLFONT_NBYTES); break;
	case 'F':  memcpy(&temp, CPLOT_SMALLFONT_F, CPLOT_SMALLFONT_NBYTES); break;
	case 'G':  memcpy(&temp, CPLOT_SMALLFONT_G, CPLOT_SMALLFONT_NBYTES); break;
	case 'H':  memcpy(&temp, CPLOT_SMALLFONT_H, CPLOT_SMALLFONT_NBYTES); break;
	case 'I':  memcpy(&temp, CPLOT_SMALLFONT_I, CPLOT_SMALLFONT_NBYTES); break;
	case 'J':  memcpy(&temp, CPLOT_SMALLFONT_J, CPLOT_SMALLFONT_NBYTES); break;
	case 'K':  memcpy(&temp, CPLOT_SMALLFONT_K, CPLOT_SMALLFONT_NBYTES); break;
	case 'L':  memcpy(&temp, CPLOT_SMALLFONT_L, CPLOT_SMALLFONT_NBYTES); break;
	case 'M':  memcpy(&temp, CPLOT_SMALLFONT_M, CPLOT_SMALLFONT_NBYTES); break;
	case 'N':  memcpy(&temp, CPLOT_SMALLFONT_N, CPLOT_SMALLFONT_NBYTES); break;
	case 'O':  memcpy(&temp, CPLOT_SMALLFONT_O, CPLOT_SMALLFONT_NBYTES); break;
	case 'P':  memcpy(&temp, CPLOT_SMALLFONT_P, CPLOT_SMALLFONT_NBYTES); break;
	case 'Q':  memcpy(&temp, CPLOT_SMALLFONT_Q, CPLOT_SMALLFONT_NBYTES); break;
	case 'R':  memcpy(&temp, CPLOT_SMALLFONT_R, CPLOT_SMALLFONT_NBYTES); break;
	case 'S':  memcpy(&temp, CPLOT_SMALLFONT_S, CPLOT_SMALLFONT_NBYTES); break;
	case 'T':  memcpy(&temp, CPLOT_SMALLFONT_T, CPLOT_SMALLFONT_NBYTES); break;
	case 'U':  memcpy(&temp, CPLOT_SMALLFONT_U, CPLOT_SMALLFONT_NBYTES); break;
	case 'V':  memcpy(&temp, CPLOT_SMALLFONT_V, CPLOT_SMALLFONT_NBYTES); break;
	case 'W':  memcpy(&temp, CPLOT_SMALLFONT_W, CPLOT_SMALLFONT_NBYTES); break;
	case 'X':  memcpy(&temp, CPLOT_SMALLFONT_X, CPLOT_SMALLFONT_NBYTES); break;
	case 'Y':  memcpy(&temp, CPLOT_SMALLFONT_Y, CPLOT_SMALLFONT_NBYTES); break;
	case 'Z':  memcpy(&temp, CPLOT_SMALLFONT_Z, CPLOT_SMALLFONT_NBYTES); break;


	case 'a':  memcpy(&temp, CPLOT_SMALLFONT_a, CPLOT_SMALLFONT_NBYTES); break;
	case 'b':  memcpy(&temp, CPLOT_SMALLFONT_b, CPLOT_SMALLFONT_NBYTES); break;
	case 'c':  memcpy(&temp, CPLOT_SMALLFONT_c, CPLOT_SMALLFONT_NBYTES); break;
	case 'd':  memcpy(&temp, CPLOT_SMALLFONT_d, CPLOT_SMALLFONT_NBYTES); break;
	case 'e':  memcpy(&temp, CPLOT_SMALLFONT_e, CPLOT_SMALLFONT_NBYTES); break;
	case 'f':  memcpy(&temp, CPLOT_SMALLFONT_f, CPLOT_SMALLFONT_NBYTES); break;
	case 'g':  memcpy(&temp, CPLOT_SMALLFONT_g, CPLOT_SMALLFONT_NBYTES); break;
	case 'h':  memcpy(&temp, CPLOT_SMALLFONT_h, CPLOT_SMALLFONT_NBYTES); break;
	case 'i':  memcpy(&temp, CPLOT_SMALLFONT_i, CPLOT_SMALLFONT_NBYTES); break;
	case 'j':  memcpy(&temp, CPLOT_SMALLFONT_j, CPLOT_SMALLFONT_NBYTES); break;
	case 'k':  memcpy(&temp, CPLOT_SMALLFONT_k, CPLOT_SMALLFONT_NBYTES); break;
	case 'l':  memcpy(&temp, CPLOT_SMALLFONT_l, CPLOT_SMALLFONT_NBYTES); break;
	case 'm':  memcpy(&temp, CPLOT_SMALLFONT_m, CPLOT_SMALLFONT_NBYTES); break;
	case 'n':  memcpy(&temp, CPLOT_SMALLFONT_n, CPLOT_SMALLFONT_NBYTES); break;
	case 'o':  memcpy(&temp, CPLOT_SMALLFONT_o, CPLOT_SMALLFONT_NBYTES); break;
	case 'p':  memcpy(&temp, CPLOT_SMALLFONT_p, CPLOT_SMALLFONT_NBYTES); break;
	case 'q':  memcpy(&temp, CPLOT_SMALLFONT_q, CPLOT_SMALLFONT_NBYTES); break;
	case 'r':  memcpy(&temp, CPLOT_SMALLFONT_r, CPLOT_SMALLFONT_NBYTES); break;
	case 's':  memcpy(&temp, CPLOT_SMALLFONT_s, CPLOT_SMALLFONT_NBYTES); break;
	case 't':  memcpy(&temp, CPLOT_SMALLFONT_t, CPLOT_SMALLFONT_NBYTES); break;
	case 'u':  memcpy(&temp, CPLOT_SMALLFONT_u, CPLOT_SMALLFONT_NBYTES); break;
	case 'v':  memcpy(&temp, CPLOT_SMALLFONT_v, CPLOT_SMALLFONT_NBYTES); break;
	case 'w':  memcpy(&temp, CPLOT_SMALLFONT_w, CPLOT_SMALLFONT_NBYTES); break;
	case 'x':  memcpy(&temp, CPLOT_SMALLFONT_x, CPLOT_SMALLFONT_NBYTES); break;
	case 'y':  memcpy(&temp, CPLOT_SMALLFONT_y, CPLOT_SMALLFONT_NBYTES); break;
	case 'z':  memcpy(&temp, CPLOT_SMALLFONT_z, CPLOT_SMALLFONT_NBYTES); break;

	case '~':  memcpy(&temp, CPLOT_SMALLFONT_tilda, CPLOT_SMALLFONT_NBYTES); break;
	case '!':  memcpy(&temp, CPLOT_SMALLFONT_exclamation, CPLOT_SMALLFONT_NBYTES); break;
		// case '@':  memcpy( &temp, CPLOT_SMALLFONT_at, CPLOT_SMALLFONT_NBYTES ); break; // GDM_TODO - add
		//case '#':  memcpy( &temp, CPLOT_SMALLFONT_hash, CPLOT_SMALLFONT_NBYTES ); break; // GDM_TODO - add 
	case '$':  memcpy(&temp, CPLOT_SMALLFONT_dollarsign, CPLOT_SMALLFONT_NBYTES); break;
	case '%':  memcpy(&temp, CPLOT_SMALLFONT_percent, CPLOT_SMALLFONT_NBYTES); break;
	case '^':  memcpy(&temp, CPLOT_SMALLFONT_raiseto, CPLOT_SMALLFONT_NBYTES); break;
	case '&':  memcpy(&temp, CPLOT_SMALLFONT_andsign, CPLOT_SMALLFONT_NBYTES); break;
	case '*':  memcpy(&temp, CPLOT_SMALLFONT_star, CPLOT_SMALLFONT_NBYTES); break;
	case '(':  memcpy(&temp, CPLOT_SMALLFONT_leftbracket, CPLOT_SMALLFONT_NBYTES); break;
	case ')':  memcpy(&temp, CPLOT_SMALLFONT_rightbracket, CPLOT_SMALLFONT_NBYTES); break;
	case '-':  memcpy(&temp, CPLOT_SMALLFONT_dash, CPLOT_SMALLFONT_NBYTES); break;
		// case '_':  memcpy( &temp, CPLOT_SMALLFONT_underscore, CPLOT_SMALLFONT_NBYTES ); break; // GDM_TODO - add 
	case '+':  memcpy(&temp, CPLOT_SMALLFONT_plus, CPLOT_SMALLFONT_NBYTES); break;
	case '=':  memcpy(&temp, CPLOT_SMALLFONT_equals, CPLOT_SMALLFONT_NBYTES); break;
		// case '{':  memcpy( &temp, CPLOT_SMALLFONT_leftcurly, CPLOT_SMALLFONT_NBYTES ); break; // GDM_TODO - add 
		// case '}':  memcpy( &temp, CPLOT_SMALLFONT_rightcurly, CPLOT_SMALLFONT_NBYTES ); break; // GDM_TODO - add 
	case '|':  memcpy(&temp, CPLOT_SMALLFONT_vert, CPLOT_SMALLFONT_NBYTES); break;
	case '[':  memcpy(&temp, CPLOT_SMALLFONT_leftsquare, CPLOT_SMALLFONT_NBYTES); break;
	case ']':  memcpy(&temp, CPLOT_SMALLFONT_rightsquare, CPLOT_SMALLFONT_NBYTES); break;
	case '\\': memcpy(&temp, CPLOT_SMALLFONT_backslash, CPLOT_SMALLFONT_NBYTES); break;
	case '/':  memcpy(&temp, CPLOT_SMALLFONT_forwardslash, CPLOT_SMALLFONT_NBYTES); break;
	case ';':  memcpy(&temp, CPLOT_SMALLFONT_semicolon, CPLOT_SMALLFONT_NBYTES); break;
	case ':':  memcpy(&temp, CPLOT_SMALLFONT_colon, CPLOT_SMALLFONT_NBYTES); break;
	case '\'': memcpy(&temp, CPLOT_SMALLFONT_singlequote, CPLOT_SMALLFONT_NBYTES); break;
	case ',':  memcpy(&temp, CPLOT_SMALLFONT_comma, CPLOT_SMALLFONT_NBYTES); break;
	case '.':  memcpy(&temp, CPLOT_SMALLFONT_point, CPLOT_SMALLFONT_NBYTES); break;
	case '"':  memcpy(&temp, CPLOT_SMALLFONT_doublequote, CPLOT_SMALLFONT_NBYTES); break;
	case '<':  memcpy(&temp, CPLOT_SMALLFONT_lessthan, CPLOT_SMALLFONT_NBYTES); break;
	case '>':  memcpy(&temp, CPLOT_SMALLFONT_morethan, CPLOT_SMALLFONT_NBYTES); break;
		// case '?':  memcpy( &temp, CPLOT_SMALLFONT_questionmark, CPLOT_SMALLFONT_NBYTES ); break;// GDM_TODO - add 

	case '1':  memcpy(&temp, CPLOT_SMALLFONT_One, CPLOT_SMALLFONT_NBYTES); break;
	case '2':  memcpy(&temp, CPLOT_SMALLFONT_Two, CPLOT_SMALLFONT_NBYTES); break;
	case '3':  memcpy(&temp, CPLOT_SMALLFONT_Three, CPLOT_SMALLFONT_NBYTES); break;
	case '4':  memcpy(&temp, CPLOT_SMALLFONT_Four, CPLOT_SMALLFONT_NBYTES); break;
	case '5':  memcpy(&temp, CPLOT_SMALLFONT_Five, CPLOT_SMALLFONT_NBYTES); break;
	case '6':  memcpy(&temp, CPLOT_SMALLFONT_Six, CPLOT_SMALLFONT_NBYTES); break;
	case '7':  memcpy(&temp, CPLOT_SMALLFONT_Seven, CPLOT_SMALLFONT_NBYTES); break;
	case '8':  memcpy(&temp, CPLOT_SMALLFONT_Eight, CPLOT_SMALLFONT_NBYTES); break;
	case '9':  memcpy(&temp, CPLOT_SMALLFONT_Nine, CPLOT_SMALLFONT_NBYTES); break;
	case '0':  memcpy(&temp, CPLOT_SMALLFONT_Zero, CPLOT_SMALLFONT_NBYTES); break;

	default: break;
	}


	if (isRotatedLeft)
	{
		for (row = 0; row < klH; row++)
		{
			for (col = 0; col < klW; col++)
			{
				rotatedleft[5 - col][row] = temp[row][col];
			}
		}
	}

	// plot the letters
	if (isRotatedLeft)
	{
		for (row = 0; row < klW; row++)
		{
			for (col = 0; col < klH; col++)
			{
				if (rotatedleft[row][col])
					P->mPlotData.data[y - row][x + col] = rotatedleft[row][col] * color;
			}
		}
	}
	else
	{
		for (row = 0; row < klH; row++)
		{
			for (col = 0; col < klW; col++)
			{
				if (temp[row][col])
					P->mPlotData.data[y - row][x + col] = temp[row][col] * color;
			}
		}
	}
	return klW;
}






int CPLOT_DrawLargeLetter(
	CPLOT *P,
	const char Letter,
	const int x,
	const int y,
	BOOL isRotatedLeft,
	const CPLOT_enumColor color
)
{
	int row = 0;
	int col = 0;
	int numCols = 0;
	char letter = Letter;
	const int kSize = CPLOT_LARGEFONT;

	byte temp[CPLOT_LARGEFONT][CPLOT_LARGEFONT];
	byte rotatedleft[CPLOT_LARGEFONT][CPLOT_LARGEFONT];

	if (!P)
		return FALSE;

	memset(&temp, 0, CPLOT_LARGEFONT*CPLOT_LARGEFONT);
	memset(&rotatedleft, 0, CPLOT_LARGEFONT*CPLOT_LARGEFONT);

	switch (letter)
	{
	case 'A':   numCols = 11; break;
	case 'B':   numCols = 11; break;
	case 'C':   numCols = 11; break;
	case 'D':   numCols = 11; break;
	case 'E':   numCols = 11; break;
	case 'F':   numCols = 11; break;
	case 'G':   numCols = 11; break;
	case 'H':   numCols = 11; break;
	case 'I':   numCols = 3; break;
	case 'J':   numCols = 9; break;
	case 'K':   numCols = 11; break;
	case 'L':   numCols = 9; break;
	case 'M':   numCols = 13; break;
	case 'N':   numCols = 11; break;
	case 'O':   numCols = 12; break;
	case 'P':   numCols = 10; break;
	case 'Q':   numCols = 12; break;
	case 'R':   numCols = 11; break;
	case 'S':   numCols = 10; break;
	case 'T':   numCols = 10; break;
	case 'U':   numCols = 10; break;
	case 'V':   numCols = 9; break;
	case 'W':   numCols = 14; break;
	case 'X':   numCols = 10; break;
	case 'Y':   numCols = 9; break;
	case 'Z':   numCols = 9; break;

	case 'a':   numCols = 8; break;
	case 'b':   numCols = 9; break;
	case 'c':   numCols = 9; break;
	case 'd':   numCols = 9; break;
	case 'e':   numCols = 9; break;
	case 'f':   numCols = 7; break;
	case 'g':   numCols = 9; break;
	case 'h':   numCols = 9; break;
	case 'i':   numCols = 4; break;
	case 'j':   numCols = 6; break;
	case 'k':   numCols = 8; break;
	case 'l':   numCols = 4; break;
	case 'm':   numCols = 12; break;
	case 'n':   numCols = 9; break;
	case 'o':   numCols = 9; break;
	case 'p':   numCols = 9; break;
	case 'q':   numCols = 9; break;
	case 'r':   numCols = 6; break;
	case 's':   numCols = 7; break;
	case 't':   numCols = 6; break;
	case 'u':   numCols = 9; break;
	case 'v':   numCols = 8; break;
	case 'w':   numCols = 12; break;
	case 'x':   numCols = 7; break;
	case 'y':   numCols = 8; break;
	case 'z':   numCols = 8; break;

	case '~':   numCols = 10; break;
	case '!':   numCols = 4; break;
	case '@':   numCols = 12; break;
	case '#':   numCols = 9; break;
	case '$':   numCols = 10; break;
	case '%':   numCols = 14; break;
	case '^':   numCols = 10; break;
	case '&':   numCols = 11; break;
	case '*':   numCols = 8; break;
	case '(':   numCols = 5; break;
	case ')':   numCols = 5; break;
	case '-':   numCols = 5; break;
	case '_':   numCols = 9; break;
	case '+':   numCols = 10; break;
	case '=':   numCols = 10; break;
	case '{':   numCols = 6; break;
	case '}':   numCols = 6; break;
	case '|':   numCols = 5; break;
	case '[':   numCols = 5; break;
	case ']':   numCols = 5; break;
	case '\\':  numCols = 6; break;
	case '/':   numCols = 6; break;
	case ';':   numCols = 4; break;
	case ':':   numCols = 4; break;
	case '\'':  numCols = 4; break;
	case ',':   numCols = 4; break;
	case '.':   numCols = 4; break;
	case '"':   numCols = 8; break;
	case '<':   numCols = 9; break;
	case '>':   numCols = 9; break;
	case '?':   numCols = 9; break;

	case '1':   numCols = 7; break;
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case '0':   numCols = 8; break;

	case -1:  numCols = 12; break;

	default: numCols = 5; break;
	}


	switch (letter)
	{
	case 'A':  memcpy(&temp, CPLOT_LARGEFONT_A, CPLOT_LARGEFONT_NBYTES); break;
	case 'B':  memcpy(&temp, CPLOT_LARGEFONT_B, CPLOT_LARGEFONT_NBYTES); break;
	case 'C':  memcpy(&temp, CPLOT_LARGEFONT_C, CPLOT_LARGEFONT_NBYTES); break;
	case 'D':  memcpy(&temp, CPLOT_LARGEFONT_D, CPLOT_LARGEFONT_NBYTES); break;
	case 'E':  memcpy(&temp, CPLOT_LARGEFONT_E, CPLOT_LARGEFONT_NBYTES); break;
	case 'F':  memcpy(&temp, CPLOT_LARGEFONT_F, CPLOT_LARGEFONT_NBYTES); break;
	case 'G':  memcpy(&temp, CPLOT_LARGEFONT_G, CPLOT_LARGEFONT_NBYTES); break;
	case 'H':  memcpy(&temp, CPLOT_LARGEFONT_H, CPLOT_LARGEFONT_NBYTES); break;
	case 'I':  memcpy(&temp, CPLOT_LARGEFONT_I, CPLOT_LARGEFONT_NBYTES); break;
	case 'J':  memcpy(&temp, CPLOT_LARGEFONT_J, CPLOT_LARGEFONT_NBYTES); break;
	case 'K':  memcpy(&temp, CPLOT_LARGEFONT_K, CPLOT_LARGEFONT_NBYTES); break;
	case 'L':  memcpy(&temp, CPLOT_LARGEFONT_L, CPLOT_LARGEFONT_NBYTES); break;
	case 'M':  memcpy(&temp, CPLOT_LARGEFONT_M, CPLOT_LARGEFONT_NBYTES); break;
	case 'N':  memcpy(&temp, CPLOT_LARGEFONT_N, CPLOT_LARGEFONT_NBYTES); break;
	case 'O':  memcpy(&temp, CPLOT_LARGEFONT_O, CPLOT_LARGEFONT_NBYTES); break;
	case 'P':  memcpy(&temp, CPLOT_LARGEFONT_P, CPLOT_LARGEFONT_NBYTES); break;
	case 'Q':  memcpy(&temp, CPLOT_LARGEFONT_Q, CPLOT_LARGEFONT_NBYTES); break;
	case 'R':  memcpy(&temp, CPLOT_LARGEFONT_R, CPLOT_LARGEFONT_NBYTES); break;
	case 'S':  memcpy(&temp, CPLOT_LARGEFONT_S, CPLOT_LARGEFONT_NBYTES); break;
	case 'T':  memcpy(&temp, CPLOT_LARGEFONT_T, CPLOT_LARGEFONT_NBYTES); break;
	case 'U':  memcpy(&temp, CPLOT_LARGEFONT_U, CPLOT_LARGEFONT_NBYTES); break;
	case 'V':  memcpy(&temp, CPLOT_LARGEFONT_V, CPLOT_LARGEFONT_NBYTES); break;
	case 'W':  memcpy(&temp, CPLOT_LARGEFONT_W, CPLOT_LARGEFONT_NBYTES); break;
	case 'X':  memcpy(&temp, CPLOT_LARGEFONT_X, CPLOT_LARGEFONT_NBYTES); break;
	case 'Y':  memcpy(&temp, CPLOT_LARGEFONT_Y, CPLOT_LARGEFONT_NBYTES); break;
	case 'Z':  memcpy(&temp, CPLOT_LARGEFONT_Z, CPLOT_LARGEFONT_NBYTES); break;


	case 'a':  memcpy(&temp, CPLOT_LARGEFONT_a, CPLOT_LARGEFONT_NBYTES); break;
	case 'b':  memcpy(&temp, CPLOT_LARGEFONT_b, CPLOT_LARGEFONT_NBYTES); break;
	case 'c':  memcpy(&temp, CPLOT_LARGEFONT_c, CPLOT_LARGEFONT_NBYTES); break;
	case 'd':  memcpy(&temp, CPLOT_LARGEFONT_d, CPLOT_LARGEFONT_NBYTES); break;
	case 'e':  memcpy(&temp, CPLOT_LARGEFONT_e, CPLOT_LARGEFONT_NBYTES); break;
	case 'f':  memcpy(&temp, CPLOT_LARGEFONT_f, CPLOT_LARGEFONT_NBYTES); break;
	case 'g':  memcpy(&temp, CPLOT_LARGEFONT_g, CPLOT_LARGEFONT_NBYTES); break;
	case 'h':  memcpy(&temp, CPLOT_LARGEFONT_h, CPLOT_LARGEFONT_NBYTES); break;
	case 'i':  memcpy(&temp, CPLOT_LARGEFONT_i, CPLOT_LARGEFONT_NBYTES); break;
	case 'j':  memcpy(&temp, CPLOT_LARGEFONT_j, CPLOT_LARGEFONT_NBYTES); break;
	case 'k':  memcpy(&temp, CPLOT_LARGEFONT_k, CPLOT_LARGEFONT_NBYTES); break;
	case 'l':  memcpy(&temp, CPLOT_LARGEFONT_l, CPLOT_LARGEFONT_NBYTES); break;
	case 'm':  memcpy(&temp, CPLOT_LARGEFONT_m, CPLOT_LARGEFONT_NBYTES); break;
	case 'n':  memcpy(&temp, CPLOT_LARGEFONT_n, CPLOT_LARGEFONT_NBYTES); break;
	case 'o':  memcpy(&temp, CPLOT_LARGEFONT_o, CPLOT_LARGEFONT_NBYTES); break;
	case 'p':  memcpy(&temp, CPLOT_LARGEFONT_p, CPLOT_LARGEFONT_NBYTES); break;
	case 'q':  memcpy(&temp, CPLOT_LARGEFONT_q, CPLOT_LARGEFONT_NBYTES); break;
	case 'r':  memcpy(&temp, CPLOT_LARGEFONT_r, CPLOT_LARGEFONT_NBYTES); break;
	case 's':  memcpy(&temp, CPLOT_LARGEFONT_s, CPLOT_LARGEFONT_NBYTES); break;
	case 't':  memcpy(&temp, CPLOT_LARGEFONT_t, CPLOT_LARGEFONT_NBYTES); break;
	case 'u':  memcpy(&temp, CPLOT_LARGEFONT_u, CPLOT_LARGEFONT_NBYTES); break;
	case 'v':  memcpy(&temp, CPLOT_LARGEFONT_v, CPLOT_LARGEFONT_NBYTES); break;
	case 'w':  memcpy(&temp, CPLOT_LARGEFONT_w, CPLOT_LARGEFONT_NBYTES); break;
	case 'x':  memcpy(&temp, CPLOT_LARGEFONT_x, CPLOT_LARGEFONT_NBYTES); break;
	case 'y':  memcpy(&temp, CPLOT_LARGEFONT_y, CPLOT_LARGEFONT_NBYTES); break;
	case 'z':  memcpy(&temp, CPLOT_LARGEFONT_z, CPLOT_LARGEFONT_NBYTES); break;

	case '~':  memcpy(&temp, CPLOT_LARGEFONT_tilda, CPLOT_LARGEFONT_NBYTES); break;
	case '!':  memcpy(&temp, CPLOT_LARGEFONT_exclamation, CPLOT_LARGEFONT_NBYTES); break;
	case '@':  memcpy(&temp, CPLOT_LARGEFONT_at, CPLOT_LARGEFONT_NBYTES); break;
	case '#':  memcpy(&temp, CPLOT_LARGEFONT_hash, CPLOT_LARGEFONT_NBYTES); break;
	case '$':  memcpy(&temp, CPLOT_LARGEFONT_dollarsign, CPLOT_LARGEFONT_NBYTES); break;
	case '%':  memcpy(&temp, CPLOT_LARGEFONT_percent, CPLOT_LARGEFONT_NBYTES); break;
	case '^':  memcpy(&temp, CPLOT_LARGEFONT_raiseto, CPLOT_LARGEFONT_NBYTES); break;
	case '&':  memcpy(&temp, CPLOT_LARGEFONT_andsign, CPLOT_LARGEFONT_NBYTES); break;
	case '*':  memcpy(&temp, CPLOT_LARGEFONT_star, CPLOT_LARGEFONT_NBYTES); break;
	case '(':  memcpy(&temp, CPLOT_LARGEFONT_leftbracket, CPLOT_LARGEFONT_NBYTES); break;
	case ')':  memcpy(&temp, CPLOT_LARGEFONT_rightbracket, CPLOT_LARGEFONT_NBYTES); break;
	case '-':  memcpy(&temp, CPLOT_LARGEFONT_dash, CPLOT_LARGEFONT_NBYTES); break;
	case '_':  memcpy(&temp, CPLOT_LARGEFONT_underscore, CPLOT_LARGEFONT_NBYTES); break;
	case '+':  memcpy(&temp, CPLOT_LARGEFONT_plus, CPLOT_LARGEFONT_NBYTES); break;
	case '=':  memcpy(&temp, CPLOT_LARGEFONT_equals, CPLOT_LARGEFONT_NBYTES); break;
	case '{':  memcpy(&temp, CPLOT_LARGEFONT_leftcurly, CPLOT_LARGEFONT_NBYTES); break;
	case '}':  memcpy(&temp, CPLOT_LARGEFONT_rightcurly, CPLOT_LARGEFONT_NBYTES); break;
	case '|':  memcpy(&temp, CPLOT_LARGEFONT_vert, CPLOT_LARGEFONT_NBYTES); break;
	case '[':  memcpy(&temp, CPLOT_LARGEFONT_leftsquare, CPLOT_LARGEFONT_NBYTES); break;
	case ']':  memcpy(&temp, CPLOT_LARGEFONT_rightsquare, CPLOT_LARGEFONT_NBYTES); break;
	case '\\': memcpy(&temp, CPLOT_LARGEFONT_backslash, CPLOT_LARGEFONT_NBYTES); break;
	case '/':  memcpy(&temp, CPLOT_LARGEFONT_forwardslash, CPLOT_LARGEFONT_NBYTES); break;
	case ';':  memcpy(&temp, CPLOT_LARGEFONT_semicolon, CPLOT_LARGEFONT_NBYTES); break;
	case ':':  memcpy(&temp, CPLOT_LARGEFONT_colon, CPLOT_LARGEFONT_NBYTES); break;
	case '\'': memcpy(&temp, CPLOT_LARGEFONT_singlequote, CPLOT_LARGEFONT_NBYTES); break;
	case ',':  memcpy(&temp, CPLOT_LARGEFONT_comma, CPLOT_LARGEFONT_NBYTES); break;
	case '.':  memcpy(&temp, CPLOT_LARGEFONT_point, CPLOT_LARGEFONT_NBYTES); break;
	case '"':  memcpy(&temp, CPLOT_LARGEFONT_doublequote, CPLOT_LARGEFONT_NBYTES); break;
	case '<':  memcpy(&temp, CPLOT_LARGEFONT_lessthan, CPLOT_LARGEFONT_NBYTES); break;
	case '>':  memcpy(&temp, CPLOT_LARGEFONT_morethan, CPLOT_LARGEFONT_NBYTES); break;
	case '?':  memcpy(&temp, CPLOT_LARGEFONT_questionmark, CPLOT_LARGEFONT_NBYTES); break;

	case '1':  memcpy(&temp, CPLOT_LARGEFONT_One, CPLOT_LARGEFONT_NBYTES); break;
	case '2':  memcpy(&temp, CPLOT_LARGEFONT_Two, CPLOT_LARGEFONT_NBYTES); break;
	case '3':  memcpy(&temp, CPLOT_LARGEFONT_Three, CPLOT_LARGEFONT_NBYTES); break;
	case '4':  memcpy(&temp, CPLOT_LARGEFONT_Four, CPLOT_LARGEFONT_NBYTES); break;
	case '5':  memcpy(&temp, CPLOT_LARGEFONT_Five, CPLOT_LARGEFONT_NBYTES); break;
	case '6':  memcpy(&temp, CPLOT_LARGEFONT_Six, CPLOT_LARGEFONT_NBYTES); break;
	case '7':  memcpy(&temp, CPLOT_LARGEFONT_Seven, CPLOT_LARGEFONT_NBYTES); break;
	case '8':  memcpy(&temp, CPLOT_LARGEFONT_Eight, CPLOT_LARGEFONT_NBYTES); break;
	case '9':  memcpy(&temp, CPLOT_LARGEFONT_Nine, CPLOT_LARGEFONT_NBYTES); break;
	case '0':  memcpy(&temp, CPLOT_LARGEFONT_Zero, CPLOT_LARGEFONT_NBYTES); break;

	case -1:  memcpy(&temp, CPLOT_LARGEFONT_sigma, CPLOT_LARGEFONT_NBYTES); break;

	default: break;
	}

	if (isRotatedLeft)
	{
		for (row = 0; row < kSize; row++)
		{
			for (col = 0; col < kSize; col++)
			{
				rotatedleft[kSize - row - 1][col] = temp[col][row];
			}
		}
	}

	// plot the letters
	if (isRotatedLeft)
	{
		if (y < kSize)
			return 0;

		if (x + kSize >= P->mImage.Width)
			return 0;

		for (row = kSize - numCols; row < kSize; row++)
		{
			for (col = 0; col < kSize; col++)
			{
				if (rotatedleft[row][col])
					P->mPlotData.data[y - row][x + col] = (rotatedleft[row][col]) * color;
			}
		}
	}
	else
	{
		if (y < kSize)
			return 0;

		if (x + numCols >= P->mImage.Width)
			return 0;

		for (row = 0; row < kSize; row++)
		{
			for (col = 0; col < numCols; col++)
			{
				if (temp[row][col])
					P->mPlotData.data[y - row][x + col] = (temp[row][col]) * color;
			}
		}
	}

	return numCols;
}

BOOL CPLOT_DrawString(
	CPLOT *P,
	const char* str,
	const int left,
	const int top,
	const BOOL useLargeFont,
	const BOOL isRotatedLeft,
	const CPLOT_enumColor color
)
{
	int length;

	int offset = 0,
		i = 0,
		letterWidth = 0;

	if (str == NULL)
		return TRUE; // nothing to draw

	length = (int)strlen(str);

	if (!P)
		return FALSE;
	if (!str)
		return FALSE;

	if (left >= P->mImage.Width)
		return TRUE;
	if (top >= P->mImage.Height)
		return TRUE;

	if (strstr(str, "\\sigma"))
	{
		letterWidth = CPLOT_DrawLargeLetter(P, -1, left, top + offset, isRotatedLeft, color);  // GDM_HACK - a hack for now.
	}
	else
	{
		for (i = 0; i < length; i++)
		{
			if (isRotatedLeft)
			{
				if (top + offset > P->mImage.Height)
					break;

				if (useLargeFont)
					letterWidth = CPLOT_DrawLargeLetter(P, str[i], left, top + offset, isRotatedLeft, color);
				else
					letterWidth = CPLOT_DrawSmallLetter(P, str[i], left, top + offset, isRotatedLeft, color);
			}
			else
			{
				if (left + offset > P->mImage.Width)
					break;

				if (useLargeFont)
					letterWidth = CPLOT_DrawLargeLetter(P, str[i], left + offset, top, isRotatedLeft, color);
				else
					letterWidth = CPLOT_DrawSmallLetter(P, str[i], left + offset, top, isRotatedLeft, color);

			}
			offset += letterWidth;
		}
	}
	return TRUE;
}




BOOL CPLOT_DrawValue(
	CPLOT *P,
	const BOOL leftalign,
	double value,
	const int left,
	const int top,
	const CPLOT_enumColor color
)
{
	const int kTextWidth = 6 * 13;
	char ValueBuffer[48];
	size_t length = 0;

	if (!P)
		return FALSE;

	ValueBuffer[0] = '\0';

	if (leftalign)
	{
#ifndef _CRT_SECURE_NO_DEPRECATE
		sprintf_s(ValueBuffer, 48, "%-13.7g", value);
#else
		sprintf(ValueBuffer, "%-13.7g", value);
#endif
	}
	else
	{
#ifndef _CRT_SECURE_NO_DEPRECATE
		sprintf_s(ValueBuffer, 48, "%13.7g", value);
#else
		sprintf(ValueBuffer, "%13.7g", value);
#endif
	}


	if ((left + kTextWidth) >= P->mImage.Width)
		return TRUE;
	if (top >= P->mImage.Height)
		return TRUE;

	length = strlen(ValueBuffer);

	if (!CPLOT_DrawString(P, ValueBuffer, left, top, TRUE, FALSE, color))
		return FALSE;

	return TRUE;
}



BOOL CPLOT_ResizePlot(CPLOT *P)
{
	//---------------------------mImage.Width--------------------------------//
	//|               |                                |                    |
	//|               mTitleAllowance                  |                    |
	//|               |                                |                    |
	//|               |--------------------------------+                    |
	//|<-mYLabelAll.->|                                |<-mRightYLabelAll.->|
	//|               |                                |                    |
	//|               |                                |                    |
	//|               |                                |                    |
	//mImage.Height   |                              mAxes.Height           |
	//|               |                                |                    |
	//|               |                                |                    |
	//|               |                                |                    |
	//|               +--------mAxes.Width-------------+                    |
	//|               |                                |                    |
	//|               mXLabelAllowance                 |                    |
	//|               |                                |                    |
	//|               |                                |                    |
	//---------------------------mImage.Width--------------------------------//
	int previousWidth = 0;
	int rem = 0;

	if (!P)
		return FALSE;

	if (P->mOptions.PlotSize_Width_cm % 2)
		P->mAxes.Width = P->mOptions.PlotSize_Width_cm*CPLOT_PIXELS_PER_CM + 2;
	else
		P->mAxes.Width = P->mOptions.PlotSize_Width_cm*CPLOT_PIXELS_PER_CM;

	P->mAxes.Height = P->mOptions.PlotSize_Height_cm*CPLOT_PIXELS_PER_CM;

	if (P->mOptions.title == NULL)
		P->mTitleAllowance = 50;

	if (P->mOptions.x.label == NULL)
		P->mXLabelAllowance = 15;

	if (P->mOptions.y_label_right != NULL)
		P->mRightYLabelAllowance = 112;

	previousWidth = P->mImage.Width;
	P->mImage.Width = P->mAxes.Width + P->mRightYLabelAllowance + P->mYLabelAllowance;

	// The width must be evely divisible by four
	rem = P->mImage.Width % 4;
	P->mImage.Width += rem;

	P->mImage.Height = P->mAxes.Height + P->mXLabelAllowance + P->mTitleAllowance;

	if (P->mImage.Width < 700 &&
		P->mOptions.plotStatistics &&
		P->mOptions.plotLabelOnRight == FALSE)
	{
		P->mImage.Width = 700;
	}

	// define the start and end of the plot window
	P->mAxes.StartX = P->mYLabelAllowance; // fixed
	P->mAxes.FinishX = P->mAxes.StartX + P->mAxes.Width;

	P->mAxes.StartY = P->mXLabelAllowance;
	P->mAxes.FinishY = P->mAxes.StartY + P->mAxes.Height;


	// increase the Figure height or width for
	// labeling only or
	// stats box on right or
	// stats box on bottom
	if (P->mOptions.plotLabelOnRight)
	{
		if (P->mOptions.plotStatistics)
		{
			P->mLabelWidth = 112;
			switch (P->mOptions.numberOfSeries)
			{
			case 1:
			case 2:
			case 3: P->mImage.Width += P->mOptions.numberOfSeries*P->mLabelWidth + 44; break;
			case 4:
			case 5:
			case 6:
			case 7:
			case 8:
			case 9:
			case 10:
			case 11:
			case 12: P->mImage.Width += 3 * P->mLabelWidth + 44; break;
			default: break;
			}
		}
		else
		{
			P->mImage.Width += 120;
		}
	}
	else
	{
		P->mImage.Height += P->mOptions.numberOfSeries * 20 + 20;
		P->mAxes.StartY += P->mOptions.numberOfSeries * 20 + 20;
		P->mAxes.FinishY += P->mOptions.numberOfSeries * 20 + 20;
	}

	if (previousWidth > P->mImage.Width)
		P->mImage.Width = previousWidth;

	// The width must be evely divisible by four
	rem = P->mImage.Width % 4;
	P->mImage.Width += rem;


	if (!CPLOT_BYTE_MTX_calloc(&(P->mPlotData), P->mImage.Height, P->mImage.Width))
		return FALSE;

	return TRUE;
}


BOOL CPLOT_IsNAN(double value)
{
#ifdef WIN32
	if (_isnan(value))
		return TRUE;
	else
		return FALSE;
#else
	if (isnan(value))
		return TRUE;
	else
		return FALSE;
#endif
}



BOOL CPLOT_IsPostiveINF(double value)
{
#ifdef WIN32
	if (_finite(value))
	{
		return FALSE;
	}
	else
	{
		if (value > 0)
			return TRUE;
		else
			return FALSE;
	}
#else
	if (isfinite(value))
	{
		return FALSE;
	}
	else
	{
		if (value > 0)
			return TRUE;
		else
			return FALSE;
	}
#endif
}


BOOL CPLOT_IsNegativeINF(double value)
{
#ifdef WIN32
	if (_finite(value))
	{
		return FALSE;
	}
	else
	{
		if (value < 0)
			return TRUE;
		else
			return FALSE;
	}
#else
	if (isfinite(value))
	{
		return FALSE;
	}
	else
	{
		if (value < 0)
			return TRUE;
		else
			return FALSE;
	}
#endif
}




BOOL CPLOT_DetermineSeriesStatistics(CPLOT_structSeries *series)
{
	int i;
	int n; // the number of items in the series.
	int n_tmp; // the number of items that are not NaN.
	int index_a;
	int index_b;
	double sumx2 = 0;
	double sumx = 0;
	BOOL isIPPSEnabled = FALSE;
	BOOL computeStats = TRUE;

	if (!series)
		return FALSE;

	index_a = index_b = 0;
	n = series->n;

	memset(&(series->xStats), 0, sizeof(CPLOT_structStats));
	memset(&(series->yStats), 0, sizeof(CPLOT_structStats));

	if (n == 0)
	{
		return TRUE;
	}

	if (n == 1)
	{
		series->xStats.min = series->X[0];
		series->xStats.max = series->X[0];
		series->xStats.mean = series->X[0];
		series->xStats.stdev = 0.0;
		series->xStats.rms = series->X[0];
		series->xStats.range = 0.0;

		series->yStats.min = series->Y[0];
		series->yStats.max = series->Y[0];
		series->yStats.mean = series->Y[0];
		series->yStats.stdev = 0.0;
		series->yStats.rms = series->Y[0];
		series->yStats.range = 0.0;
		return TRUE;
	}

#ifdef INTEL_IPPS

	isIPPSEnabled = TRUE;

	if (ippsMinMaxIndx_64f(series->X, n, &(series->xStats.min), &index_a, &(series->xStats.max), &index_b) != ippStsNoErr)
		return FALSE;
	if (series->xStats.min > series->X[index_a]) // possible IPPS bug due to NaN or INF
		series->xStats.min = series->X[index_a];
	if (series->xStats.max < series->X[index_b]) // possible IPPS bug due to NaN or INF
		series->xStats.max = series->X[index_b];

	if (ippsMinMaxIndx_64f(series->Y, n, &(series->yStats.min), &index_a, &(series->yStats.max), &index_b) != ippStsNoErr)
		return FALSE;
	if (series->yStats.min > series->Y[index_a]) // possible IPPS bug due to NaN or INF
		series->yStats.min = series->Y[index_a];
	if (series->yStats.max < series->Y[index_b]) // possible IPPS bug due to NaN or INF
		series->yStats.max = series->Y[index_b];

	series->xStats.range = series->xStats.max - series->xStats.min;
	series->yStats.range = series->yStats.max - series->yStats.min;

	if (ippsSum_64f(series->X, n, &(series->xStats.mean)) != ippStsNoErr)
		return FALSE;
	series->xStats.mean /= (double)(n);

	if (ippsSum_64f(series->Y, n, &(series->yStats.mean)) != ippStsNoErr)
		return FALSE;
	series->yStats.mean /= (double)(n);

	// Compute RMS
	if (ippsNorm_L2_64f(series->X, n, &(series->xStats.rms)) != ippStsNoErr)
		return FALSE;
	series->xStats.rms /= sqrt((double)(n));
	if (ippsNorm_L2_64f(series->Y, n, &(series->yStats.rms)) != ippStsNoErr)
		return FALSE;
	series->yStats.rms /= sqrt((double)(n));

	computeStats = FALSE;

#endif

	if (isIPPSEnabled)
	{
		// Check IPPS for NaN and INF bad values.
		do
		{
			if (CPLOT_IsNAN(series->xStats.min) || CPLOT_IsPostiveINF(series->xStats.min) || CPLOT_IsNegativeINF(series->xStats.min))
			{
				computeStats = TRUE;
				break;
			}
			if (CPLOT_IsNAN(series->xStats.max) || CPLOT_IsPostiveINF(series->xStats.max) || CPLOT_IsNegativeINF(series->xStats.max))
			{
				computeStats = TRUE;
				break;
			}
			if (CPLOT_IsNAN(series->xStats.mean) || CPLOT_IsPostiveINF(series->xStats.mean) || CPLOT_IsNegativeINF(series->xStats.mean))
			{
				computeStats = TRUE;
				break;
			}
			if (CPLOT_IsNAN(series->xStats.rms) || CPLOT_IsPostiveINF(series->xStats.rms) || CPLOT_IsNegativeINF(series->xStats.rms))
			{
				computeStats = TRUE;
				break;
			}
		} while (0);
	}

	// These statistics ignore NaN and INF values for min, max, range, mean. 
	// stdev and RMS will ignore NaN but not INF.
	if (computeStats)
	{
		series->xStats.min = DBL_MAX;
		series->xStats.max = -DBL_MAX;
		n_tmp = 0;
		for (i = 0; i < n; i++)
		{
			// ignore NaN and INF.
			if (CPLOT_IsNAN(series->X[i]) || CPLOT_IsPostiveINF(series->X[i]) || CPLOT_IsNegativeINF(series->X[i]))
				continue;

			if (series->X[i] < series->xStats.min)
			{
				series->xStats.min = series->X[i];
			}
			if (series->X[i] > series->xStats.max)
			{
				series->xStats.max = series->X[i];
			}
			series->xStats.mean += series->X[i];
			n_tmp++;
		}
		series->xStats.range = series->xStats.max - series->xStats.min;
		if (n_tmp)
		{
			series->xStats.mean /= (double)(n_tmp);
		}


		series->yStats.min = DBL_MAX;
		series->yStats.max = -DBL_MAX;
		n_tmp = 0;
		for (i = 0; i < n; i++)
		{
			// ignore NaN and INF.
			if (CPLOT_IsNAN(series->Y[i]) || CPLOT_IsPostiveINF(series->Y[i]) || CPLOT_IsNegativeINF(series->Y[i]))
				continue;

			if (series->Y[i] < series->yStats.min)
			{
				series->yStats.min = series->Y[i];
			}
			if (series->Y[i] > series->yStats.max)
			{
				series->yStats.max = series->Y[i];
			}
			series->yStats.mean += series->Y[i];
			n_tmp++;
		}
		series->yStats.range = series->yStats.max - series->yStats.min;
		if (n_tmp)
		{
			series->yStats.mean /= (double)(n_tmp);
		}

		// Compute RMS
		series->xStats.rms = 0;
		n_tmp = 0;
		for (i = 0; i < n; i++)
		{
			if (!CPLOT_IsNAN(series->X[i]))
			{
				series->xStats.rms += series->X[i] * series->X[i];
				n_tmp++;
			}
		}
		if (n_tmp)
		{
			series->xStats.rms /= (double)(n_tmp);
			series->xStats.rms = sqrt(series->xStats.rms);
		}

		series->yStats.rms = 0;
		n_tmp = 0;
		for (i = 0; i < n; i++)
		{
			if (!CPLOT_IsNAN(series->Y[i]))
			{
				series->yStats.rms += series->Y[i] * series->Y[i];
				n_tmp++;
			}
		}
		if (n_tmp)
		{
			series->yStats.rms /= (double)(n_tmp);
			series->yStats.rms = sqrt(series->yStats.rms);
		}
	}

	// Always compute stdev 'manually'.
	n_tmp = 0;
	for (i = 0; i < n; i++)
	{
		if (!CPLOT_IsNAN(series->X[i]))
		{
			sumx += series->X[i];
			sumx2 += series->X[i] * series->X[i];
			n_tmp++;
		}
	}
	if (CPLOT_IsPostiveINF(sumx2))
	{
		series->xStats.stdev = sumx2;
	}
	else
	{
		series->xStats.stdev = (n_tmp*sumx2 - sumx*sumx) / (n_tmp*(n_tmp - 1.0)); // variance
		series->xStats.stdev = sqrt(series->xStats.stdev);
	}

	n_tmp = 0;
	sumx = 0;
	sumx2 = 0;
	for (i = 0; i < n; i++)
	{
		if (!CPLOT_IsNAN(series->Y[i]))
		{
			sumx += series->Y[i];
			sumx2 += series->Y[i] * series->Y[i];
			n_tmp++;
		}
	}
	if (CPLOT_IsPostiveINF(sumx2))
	{
		series->xStats.stdev = sumx2;
	}
	else
	{
		series->yStats.stdev = (n_tmp*sumx2 - sumx*sumx) / (n_tmp*(n_tmp - 1.0)); // variance
		series->yStats.stdev = sqrt(series->yStats.stdev);
	}

	return TRUE;
}


BOOL CPLOT_DetermineScaleFactors(CPLOT *P, CPLOT_structSeries *Series)
{
	double val = 0;
	typedef struct
	{
		double lowerlimit;
		double upperlimit;
		double tickstart;
		double ticksize;
		double tickend;
	} _structAxis;
	_structAxis x;
	_structAxis y;

	if (!P)
		return FALSE;

	// First deal with the upper and lower limits and the tick values.
	//

	// Special case - all defaults indicated
	if (!P->mOptions.x.lowerlimit.doNotUseDefault &&
		!P->mOptions.x.upperlimit.doNotUseDefault &&
		!P->mOptions.x.tickstart.doNotUseDefault &&
		!P->mOptions.x.tickend.doNotUseDefault)
	{
		val = Series->xStats.min;
		if (val < 0)
		{
			val = -ceil(-val * 10.0) / 10.0;
		}
		else
		{
			val = floor(val * 10.0) / 10.0;
		}
		x.lowerlimit = val;

		val = Series->xStats.max;
		if (val < 0)
		{
			val = -floor(-val * 10.0) / 10.0;
		}
		else
		{
			val = ceil(val * 10.0) / 10.0;
		}
		x.upperlimit = val;


		if (x.lowerlimit == x.upperlimit)
		{
			x.lowerlimit -= x.lowerlimit / 100.0;
			x.upperlimit += x.upperlimit / 100.0;
		}

		x.tickstart = x.lowerlimit;
		x.ticksize = (x.upperlimit - x.lowerlimit) / 5.0;
		x.tickend = x.upperlimit;
	}
	else
	{
		// deal with mixed or all user specified case

		if (P->mOptions.x.lowerlimit.doNotUseDefault)
			x.lowerlimit = P->mOptions.x.lowerlimit.val;
		else
			x.lowerlimit = Series->xStats.min;

		if (P->mOptions.x.upperlimit.doNotUseDefault)
			x.upperlimit = P->mOptions.x.upperlimit.val;
		else
			x.upperlimit = Series->xStats.max;

		if (P->mOptions.x.tickstart.doNotUseDefault)
			x.tickstart = P->mOptions.x.tickstart.val;
		else
			x.tickstart = x.lowerlimit;

		if (P->mOptions.x.tickend.doNotUseDefault)
			x.tickend = P->mOptions.x.tickend.val;
		else
			x.tickend = x.upperlimit;

		if (P->mOptions.x.ticksize.doNotUseDefault)
			x.ticksize = P->mOptions.x.ticksize.val;
		else
			x.ticksize = (x.tickend - x.tickstart) / 5.0;
	}
	if (x.lowerlimit == x.upperlimit)
		return FALSE;
	if (x.tickstart == x.tickend)
		return FALSE;
	if (x.ticksize <= 0.0)
		return FALSE;



	// Special case - all defaults indicated
	if (!P->mOptions.y.lowerlimit.doNotUseDefault &&
		!P->mOptions.y.upperlimit.doNotUseDefault &&
		!P->mOptions.y.tickstart.doNotUseDefault &&
		!P->mOptions.y.tickend.doNotUseDefault)
	{
		val = Series->yStats.min;
		if (val < 0)
		{
			val = -ceil(-val * 10.0) / 10.0;
		}
		else
		{
			val = floor(val * 10.0) / 10.0;
		}
		y.lowerlimit = val;

		val = Series->yStats.max;
		if (val < 0)
		{
			val = -floor(-val * 10.0) / 10.0;
		}
		else
		{
			val = ceil(val * 10.0) / 10.0;
		}
		y.upperlimit = val;


		if (y.lowerlimit == y.upperlimit)
		{
			y.lowerlimit -= y.lowerlimit / 100.0;
			y.upperlimit += y.upperlimit / 100.0;
		}

		y.tickstart = y.lowerlimit;
		y.ticksize = (y.upperlimit - y.lowerlimit) / 10.0;
		y.tickend = y.upperlimit;
	}
	else
	{
		// deal with mixed or all user specified case

		if (P->mOptions.y.lowerlimit.doNotUseDefault)
			y.lowerlimit = P->mOptions.y.lowerlimit.val;
		else
			y.lowerlimit = Series->yStats.min;

		if (P->mOptions.y.upperlimit.doNotUseDefault)
			y.upperlimit = P->mOptions.y.upperlimit.val;
		else
			y.upperlimit = Series->yStats.max;

		if (P->mOptions.y.tickstart.doNotUseDefault)
			y.tickstart = P->mOptions.y.tickstart.val;
		else
			y.tickstart = y.lowerlimit;

		if (P->mOptions.y.tickend.doNotUseDefault)
			y.tickend = P->mOptions.y.tickend.val;
		else
			y.tickend = y.upperlimit;

		if (P->mOptions.y.ticksize.doNotUseDefault)
			y.ticksize = P->mOptions.y.ticksize.val;
		else
			y.ticksize = (y.tickend - y.tickstart) / 10.0;
	}
	if (y.lowerlimit == y.upperlimit)
		return FALSE;
	if (y.tickstart == y.tickend)
		return FALSE;
	if (y.ticksize <= 0.0)
		return FALSE;

	// All the values for lower, upper, and ticks are now set.

	P->mOptions.x.lowerlimit.val = x.lowerlimit;
	P->mOptions.x.upperlimit.val = x.upperlimit;
	P->mOptions.x.tickstart.val = x.tickstart;
	P->mOptions.x.ticksize.val = x.ticksize;
	P->mOptions.x.tickend.val = x.tickend;

	P->mOptions.x.lowerlimit.doNotUseDefault = TRUE;
	P->mOptions.x.upperlimit.doNotUseDefault = TRUE;
	P->mOptions.x.tickstart.doNotUseDefault = TRUE;
	P->mOptions.x.ticksize.doNotUseDefault = TRUE;
	P->mOptions.x.tickend.doNotUseDefault = TRUE;

	P->mOptions.y.lowerlimit.val = y.lowerlimit;
	P->mOptions.y.upperlimit.val = y.upperlimit;
	P->mOptions.y.tickstart.val = y.tickstart;
	P->mOptions.y.ticksize.val = y.ticksize;
	P->mOptions.y.tickend.val = y.tickend;

	P->mOptions.y.lowerlimit.doNotUseDefault = TRUE;
	P->mOptions.y.upperlimit.doNotUseDefault = TRUE;
	P->mOptions.y.tickstart.doNotUseDefault = TRUE;
	P->mOptions.y.ticksize.doNotUseDefault = TRUE;
	P->mOptions.y.tickend.doNotUseDefault = TRUE;


	P->mData.RangeX = x.upperlimit - x.lowerlimit;
	P->mData.RangeY = y.upperlimit - y.lowerlimit;

	if (CPLOT_IsPostiveINF(P->mData.RangeX))
	{
		return FALSE;
	}
	if (CPLOT_IsPostiveINF(P->mData.RangeY))
	{
		return FALSE;
	}

	if (P->mData.RangeX == 0.0)
		P->mData.RangeX = 0.1;
	if (P->mData.RangeY == 0.0)
		P->mData.RangeY = 0.1;

	P->mData.OnePercentRangeX = P->mData.RangeX / 100.0;
	P->mData.OnePercentRangeY = P->mData.RangeY / 100.0;
	P->mData.ScaleX = P->mAxes.Width / P->mData.RangeX;
	P->mData.ScaleY = P->mAxes.Height / P->mData.RangeY;

	P->mData.MinX = x.lowerlimit;
	P->mData.MaxX = x.upperlimit;
	P->mData.MinY = y.lowerlimit;
	P->mData.MaxY = y.upperlimit;

	P->mData.xtickstart = x.tickstart;
	P->mData.xtickend = x.tickend;
	P->mData.ytickstart = y.tickstart;
	P->mData.ytickend = y.tickend;

	P->mData.xticksize = x.ticksize;
	P->mData.yticksize = y.ticksize;

	return TRUE;
}


BOOL CPLOT_GPSLabel(CPLOT *P, double tow, const int x)
{
	// for gpslabel
	int sec_since_midnight = 0,
		hour = 0,
		minute = 0,
		second = 0,
		scount = 0;
	char timeString[64];

	if (!P)
		return FALSE;

	if (tow < 0)
		return FALSE;

	tow += P->mOptions.UTCOffset;

	sec_since_midnight = (int)floor(fmod(tow, 86400.0));
	hour = sec_since_midnight / 3600;
	sec_since_midnight -= hour * 3600;

	minute = sec_since_midnight / 60;
	sec_since_midnight -= minute * 60;
	second = sec_since_midnight;

	if (hour < 10)
	{
#ifndef _CRT_SECURE_NO_DEPRECATE
		scount += sprintf_s(timeString + scount, 64 - scount, "0%d:", hour);
#else
		scount += sprintf(timeString + scount, "0%d:", hour);
#endif
	}
	else
	{
#ifndef _CRT_SECURE_NO_DEPRECATE
		scount += sprintf_s(timeString + scount, 64 - scount, "%d:", hour);
#else
		scount += sprintf(timeString + scount, "%d:", hour);
#endif
	}
	if (minute < 10)
	{
#ifndef _CRT_SECURE_NO_DEPRECATE
		scount += sprintf_s(timeString + scount, 64 - scount, "0%d:", minute);
#else
		scount += sprintf(timeString + scount, "0%d:", minute);
#endif
	}
	else
	{
#ifndef _CRT_SECURE_NO_DEPRECATE
		scount += sprintf_s(timeString + scount, 64 - scount, "%d:", minute);
#else
		scount += sprintf(timeString + scount, "%d:", minute);
#endif
	}
	if (second < 10)
	{
#ifndef _CRT_SECURE_NO_DEPRECATE
		scount += sprintf_s(timeString + scount, 64 - scount, "0%d", second);
#else
		scount += sprintf(timeString + scount, "0%d", second);
#endif
	}
	else
	{
#ifndef _CRT_SECURE_NO_DEPRECATE
		scount += sprintf_s(timeString + scount, 64 - scount, "%d", second);
#else
		scount += sprintf(timeString + scount, "%d", second);
#endif
	}

	if (!CPLOT_DrawString(P, timeString, x, P->mAxes.StartY - 20, TRUE, FALSE, CPLOT_BLACK))
		return FALSE;

	return TRUE;
}


BOOL CPLOT_Title(
	CPLOT *P,
	const char* title
)
{
	int length;
	int hpos;

	if (!P)
		return FALSE;
	if (!title)
		return FALSE;

	length = (int)strlen(title)*CPLOT_SMALLFONT_WIDTH;

	hpos = P->mAxes.StartX / 2 + (P->mAxes.Width - length) / 2;

	if (hpos < 0) // title is too long    
		return TRUE;

	if (!CPLOT_DrawString(P, title, hpos, P->mAxes.FinishY + 30, TRUE, FALSE, CPLOT_BLACK))
		return FALSE;

	return TRUE;
}

BOOL CPLOT_xLabel(
	CPLOT *P,
	const char* label
)
{
	int length;
	int hpos;

	if (!P)
		return FALSE;
	if (!label)
		return FALSE;

	length = (int)strlen(label)*CPLOT_SMALLFONT_WIDTH;

	hpos = P->mAxes.StartX / 2 + (P->mAxes.Width - length) / 2;

	if (hpos < 0) // label is too long
		return TRUE;

	if (!CPLOT_DrawString(P, label, hpos, P->mAxes.StartY - 35, TRUE, FALSE, CPLOT_BLACK))
		return FALSE;

	return TRUE;
}


BOOL CPLOT_yLabel(
	CPLOT *P,
	const char* label,
	BOOL onLeft
)
{
	int length;
	int vpos;

	if (!P)
		return FALSE;
	if (!label)
		return FALSE;

	length = (int)strlen(label)*CPLOT_SMALLFONT_WIDTH;

	vpos = P->mAxes.StartY + (P->mAxes.Height - length) / 2;

	if (vpos < 0) // label is too long
		return TRUE;

	if (onLeft)
	{
		if (!CPLOT_DrawString(P, label, 8, vpos, TRUE, TRUE, CPLOT_BLACK))
			return FALSE;
	}
	else
	{
		if (!CPLOT_DrawString(P, label, P->mAxes.FinishX + 80, vpos, TRUE, TRUE, P->mOptions.RightYLabelColor))
			return FALSE;
	}
	return TRUE;
}



BOOL CPLOT_DrawPoint(
	CPLOT *P,
	const int x,
	const int y,
	const CPLOT_enumColor color
)
{
	int i;
	int j;

	if (!P)
		return FALSE;

	if (y < 3)
		return TRUE;

	if (x + 3 >= P->mImage.Width)
		return TRUE;

	for (i = 0; i < CPLOT_POINT_SIZE; i++)
	{
		for (j = 0; j < CPLOT_POINT_SIZE; j++)
		{
			// Only draw the point, the rest is transparent.
			if (CPLOT_Point[i][j])
			{
				if (y - i + 2 >= (int)P->mPlotData.nrows)
					return FALSE;
				if (x + j - 2 >= (int)P->mPlotData.ncols)
					return FALSE;
				P->mPlotData.data[y - i + 2][x + j - 2] = color;
			}
		}
	}
	return TRUE;
}



BOOL CPLOT_DrawLargePoint(
	CPLOT *P,
	const int x,
	const int y,
	const CPLOT_enumColor color
)
{
	int i;
	int j;

	if (!P)
		return FALSE;

	if (y < 3)
		return TRUE;

	if (x + 3 >= P->mImage.Width)
		return TRUE;

	for (i = 0; i < CPLOT_LARGEPOINT_SIZE; i++)
	{
		for (j = 0; j < CPLOT_LARGEPOINT_SIZE; j++)
		{
			// Only draw the point, the rest is transparent.
			if (CPLOT_LargePoint[i][j])
			{
				if (y - i + 2 >= (int)P->mPlotData.nrows)
					return FALSE;
				if (x + j - 2 >= (int)P->mPlotData.ncols)
					return FALSE;
				P->mPlotData.data[y - i + 2][x + j - 2] = color;
			}
		}
	}
	return TRUE;
}





BOOL CPLOT_DrawLegendLabel(
	CPLOT *P,
	const char* label,
	const char* units,
	const CPLOT_enumColor color
)
{
	int ypos = 0;
	int xpos = 0;
	int xoffset = P->mRightYLabelAllowance + 47;
	char buffer[128];

	if (!P)
		return FALSE;
	if (!label)
		return FALSE;

	if (strlen(label) < 1)
		return FALSE;

	if (P->mOptions.plotLabelOnRight)
	{
		if (P->mOptions.plotStatistics)
		{
			switch (P->mSeriesIndex)
			{
			case 0:
			case 1:
			case 2:
				xpos = P->mAxes.FinishX + xoffset + P->mSeriesIndex*P->mLabelWidth;
				ypos = P->mAxes.FinishY - 8;
				break;
			case 3:
			case 4:
			case 5:
				xpos = P->mAxes.FinishX + xoffset + (P->mSeriesIndex - 3)*P->mLabelWidth;
				ypos = P->mAxes.FinishY - 8 - (P->mSeriesIndex / 3)*(P->mStatsValueHeight * 8);
				break;
			case 6:
			case 7:
			case 8:
				xpos = P->mAxes.FinishX + xoffset + (P->mSeriesIndex - 6)*P->mLabelWidth;
				ypos = P->mAxes.FinishY - 8 - (P->mSeriesIndex / 3)*(P->mStatsValueHeight * 8);
				break;
			case 9:
			case 10:
			case 11:
				xpos = P->mAxes.FinishX + xoffset + (P->mSeriesIndex - 9)*P->mLabelWidth;
				ypos = P->mAxes.FinishY - 8 - (P->mSeriesIndex / 3)*(P->mStatsValueHeight * 8);
				break;
			default:
				return TRUE; // no more than 12 series possible               
			}
			if (!CPLOT_DrawLargePoint(P, xpos - 5, ypos - 6, color))
				return FALSE;
			//DrawPoint( xpos - 6, ypos-6, color );
			//DrawPoint( xpos - 4, ypos-6, color );
			if (!CPLOT_DrawString(P, label, xpos, ypos, TRUE, FALSE, color))
				return FALSE;
			if (!CPLOT_DrawString(P, units, xpos, ypos - P->mStatsValueHeight, TRUE, FALSE, color))
				return FALSE;
		}
		else
		{
			xpos = P->mAxes.FinishX + P->mRightYLabelAllowance;
			ypos = P->mAxes.FinishY - 16 * (P->mSeriesIndex) - P->mStatsValueHeight * 8;
			if (!CPLOT_DrawLargePoint(P, xpos - 8, ypos, color))
				return FALSE;
			//DrawPoint( xpos - 6, ypos, color );
			//DrawPoint( xpos - 4, ypos, color );
			if (units && label)
			{
#ifndef _CRT_SECURE_NO_DEPRECATE
				sprintf_s(buffer, 128, "%s %s", label, units);
#else
				sprintf(buffer, "%s %s", label, units);
#endif
			}
			else if (label)
			{
#ifndef _CRT_SECURE_NO_DEPRECATE
				sprintf_s(buffer, 128, "%s", label);
#else
				sprintf(buffer, "%s", label);
#endif
			}
			else
				buffer[0] = '\0';
			if (!CPLOT_DrawString(P, buffer, xpos, ypos + 3, TRUE, FALSE, CPLOT_BLACK))
				return FALSE;
		}
	}
	else
	{
		xpos = 16;
		ypos = P->mAxes.StartY - P->mXLabelAllowance - 8 - P->mStatsValueHeight*(P->mSeriesIndex + 1);
		if (!CPLOT_DrawLargePoint(P, xpos - 8, ypos - 5, color))
			return FALSE;
		//DrawPoint( xpos - 6, ypos - 5, color );
		//DrawPoint( xpos - 4, ypos - 5, color );
		if (!CPLOT_DrawString(P, label, xpos, ypos, TRUE, FALSE, CPLOT_BLACK))
			return FALSE;
		if (!CPLOT_DrawString(P, units, 600, ypos, TRUE, FALSE, color))
			return FALSE;
	}
	return TRUE;
}





BOOL CPLOT_DrawAxes(
	CPLOT *P,
	CPLOT_structSeries *Series,
	const CPLOT_enumColor color
)
{
	double x = 0.0;
	double y = 0.0;

	double xTickRange = 0;
	double yTickRange = 0;

	int xtick;
	int ytick;


	// resize the figure if needed
	if (!CPLOT_ResizePlot(P))
		return FALSE;

	// GDM_TODO - What is the point of this part?
	if (!P->mOptions.redrawAxes)
	{
		CPLOT_BYTE_MTX_Fill(&(P->mPlotData), P->mOptions.figureBackgroundColor);
	}


	// first draw the box   
	if (!CPLOT_DrawLine(P, P->mAxes.StartX, P->mAxes.StartY, P->mAxes.FinishX, P->mAxes.StartY, color))  //bottom
		return FALSE;
	if (!CPLOT_DrawLine(P, P->mAxes.StartX, P->mAxes.StartY, P->mAxes.StartX, P->mAxes.FinishY, color)) //left side
		return FALSE;
	if (!CPLOT_DrawLine(P, P->mAxes.StartX, P->mAxes.FinishY, P->mAxes.FinishX, P->mAxes.FinishY, color)) //top
		return FALSE;
	if (!CPLOT_DrawLine(P, P->mAxes.FinishX, P->mAxes.StartY, P->mAxes.FinishX, P->mAxes.FinishY, color)) //right side
		return FALSE;

	// determine the mapping scale factors
	if (!CPLOT_DetermineScaleFactors(P, Series))
		return FALSE;

	xTickRange = P->mData.xtickend - P->mData.xtickstart;
	yTickRange = P->mData.ytickend - P->mData.ytickstart;

	// plot the xticks   
	for (x = P->mData.xtickstart; x <= P->mData.xtickend + P->mData.OnePercentRangeX; x += P->mData.xticksize)
	{
		if (Series->xStats.range > 1e-6)
		{
			if (fabs(x) < 1e-6)
				x = 0;
		}
		xtick = (int)((x - P->mData.MinX)*P->mData.ScaleX) + P->mAxes.StartX;

		if (!CPLOT_DrawLine(P, xtick, P->mAxes.StartY, xtick, P->mAxes.StartY + P->mAxes.TickDashInPixels, CPLOT_BLACK)) // bottom ticks
			return FALSE;
		if (!CPLOT_DrawLine(P, xtick, P->mAxes.FinishY - P->mAxes.TickDashInPixels, xtick, P->mAxes.FinishY, CPLOT_BLACK)) // top ticks      
			return FALSE;

		if (P->mOptions.x.label)
		{
			if (!CPLOT_DrawValue(P, TRUE, x, xtick - 3, P->mAxes.StartY - 5, color))
				return FALSE;

			if (P->mOptions.useGPSLabel)
				CPLOT_GPSLabel(P, x, xtick - 3);
		}
		if (P->mOptions.x.isGridOn)
		{
			if (!CPLOT_DrawDashedLine(P, xtick, P->mAxes.StartY, xtick, P->mAxes.FinishY, 2, color))
				return FALSE;
		}
	}

	// plot the yticks
	for (y = P->mData.ytickstart; y <= P->mData.ytickend + P->mData.OnePercentRangeY; y += P->mData.yticksize)
	{
		if (Series->yStats.range > 1e-6)
		{
			if (fabs(y) < 1e-6)
				y = 0;
		}
		ytick = (int)((y - P->mData.MinY)*P->mData.ScaleY) + P->mAxes.StartY;

		if (!CPLOT_DrawLine(P, P->mAxes.StartX, ytick, P->mAxes.StartX + P->mAxes.TickDashInPixels, ytick, color))
			return FALSE;
		if (!CPLOT_DrawLine(P, P->mAxes.FinishX - P->mAxes.TickDashInPixels, ytick, P->mAxes.FinishX, ytick, color))
			return FALSE;

		if (P->mOptions.y.label)
		{
			if (!CPLOT_DrawValue(P, FALSE, y, P->mAxes.StartX - CPLOT_SMALLFONT_WIDTH * 15, ytick + 7, color))
				return FALSE;
		}

		if (P->mOptions.y.isGridOn)
		{
			if (!CPLOT_DrawDashedLine(P, P->mAxes.StartX, ytick, P->mAxes.FinishX, ytick, 2, color))
				return FALSE;
		}

		if (P->mOptions.y_label_right != NULL)
		{
			double value = y / P->mOptions.y_label_right_scale_factor - P->mOptions.y_label_right_bias;
			if (!CPLOT_DrawValue(P, TRUE, value, P->mAxes.FinishX + 3, ytick + 7, P->mOptions.RightYLabelColor))
				return FALSE;
		}
	}


	// draw title, labels and such
	if (P->mOptions.title)
		if (!CPLOT_Title(P, P->mOptions.title))
			return FALSE;
	if (P->mOptions.x.label)
		if (!CPLOT_xLabel(P, P->mOptions.x.label))
			return FALSE;
	if (P->mOptions.y.label)
		if (!CPLOT_yLabel(P, P->mOptions.y.label, TRUE))
			return FALSE;
	if (P->mOptions.y_label_right)
		if (!CPLOT_yLabel(P, P->mOptions.y_label_right, FALSE))
			return FALSE;

	return TRUE;
}



BOOL CPLOT_DrawStatsValue(
	CPLOT *P,
	double value,
	const int left,
	const int top,
	const CPLOT_enumColor color,
	const int precision
)
{
	char formatBuffer[48];
	char ValueBuffer[48];
	ValueBuffer[0] = '\0';

	if (!P)
		return FALSE;

#ifndef _CRT_SECURE_NO_DEPRECATE
	sprintf_s(formatBuffer, 48, "%%%d.%dg", P->mLabelWidth / CPLOT_SMALLFONT_WIDTH, precision);
	sprintf_s(ValueBuffer, 48, formatBuffer, value);
#else
	sprintf(formatBuffer, "%%%d.%dg", P->mLabelWidth / CPLOT_SMALLFONT_WIDTH, precision);
	sprintf(ValueBuffer, formatBuffer, value);
#endif

	/*
	if( fabs(value) < 1e-12 )
	value = 0.0;

	if( fabs(value) > 1.0e+8 || (fabs(value) < 1.0e-8 && value != 0.0) )
	{
	sprintf( formatBuffer, "%%-%d.%de", P->mStatsValueHeight, decimalPrecision );
	sprintf( ValueBuffer, formatBuffer, value );
	}
	else
	{
	sprintf( formatBuffer, "%%-%d.%df", P->mStatsValueHeight, decimalPrecision );
	sprintf( ValueBuffer, formatBuffer, value );
	}
	*/

	if ((left + P->mLabelWidth) >= P->mImage.Width)
		return TRUE;
	if (top >= P->mImage.Height)
		return TRUE;

	if (!CPLOT_DrawString(P, ValueBuffer, left, top, TRUE, FALSE, color))
		return FALSE;

	return TRUE;
}

BOOL CPLOT_DrawStats(
	CPLOT *P,
	CPLOT_structSeries* Series
)
{
	int ypos = 0,
		xpos = 0,
		boxwidth = 45,
		boxheight = 0,
		yoffset = 0,
		xoffset = 0,
		i = 0;

	int high;
	int low;


	if (!P)
		return FALSE;
	if (!Series)
		return FALSE;

	boxheight = P->mStatsValueHeight * 7 + 1;

	if (P->mOptions.plotLabelOnRight)
	{
		switch (P->mSeriesIndex)
		{
		case 0:
		case 1:
		case 2:  ypos = P->mAxes.FinishY - 6; break;
		default: ypos = P->mAxes.FinishY - 6 - (P->mSeriesIndex / 3)*(P->mStatsValueHeight * 8); break;
			/*
			case 3:
			case 4:
			case 5: ypos = mAxes.FinishY - 6 - (mSeriesIndex/3)*(mStatsValueHeight*8); break;
			case 6:
			case 7:
			case 8: ypos = mAxes.FinishY - 6 - (mSeriesIndex/3)*(mStatsValueHeight*8); break;
			case 9:
			case 10:
			case 11: ypos = mAxes.FinishY - 6 - (mSeriesIndex/3)*(mStatsValueHeight*8); break;
			default: return; // no more than 9 series possible
			*/
		}

		// plot the box around the labels (units, min, max, mean, RMS, Stdev)
		xpos = P->mAxes.FinishX + P->mRightYLabelAllowance - 10;
		if (!CPLOT_DrawLine(P, xpos - 2, ypos - boxheight, xpos - 2, ypos, CPLOT_LIGHTGREY))
			return FALSE;
		if (!CPLOT_DrawLine(P, xpos + boxwidth, ypos - boxheight, xpos + boxwidth, ypos, CPLOT_LIGHTGREY))
			return FALSE;
		if (!CPLOT_DrawLine(P, xpos - 2, ypos, xpos + boxwidth, ypos, CPLOT_LIGHTGREY))
			return FALSE;
		if (!CPLOT_DrawLine(P, xpos - 2, ypos - boxheight, xpos + boxwidth, ypos - boxheight, CPLOT_LIGHTGREY))
			return FALSE;

		// plot the horizontal lines for the labels on the left
		ypos -= 5;
		ypos -= P->mStatsValueHeight;
		for (i = 0; i < 6; i++)
		{
			if (!CPLOT_DrawLine(
				P,
				xpos - 2,
				ypos + 5 - P->mStatsValueHeight*i,
				xpos + boxwidth,
				ypos + 5 - P->mStatsValueHeight*i,
				CPLOT_LIGHTGREY))
			{
				return FALSE;
			}
		}
		ypos += 2;
		//if( !CPLOT_DrawString( P, "Units", xpos, ypos, TRUE, FALSE, CPLOT_BLACK ) )
		//  return FALSE;
		ypos -= P->mStatsValueHeight;
		if (!CPLOT_DrawString(P, "Min", xpos, ypos, TRUE, FALSE, CPLOT_BLACK))
			return FALSE;
		ypos -= P->mStatsValueHeight;
		if (!CPLOT_DrawString(P, "Max", xpos, ypos, TRUE, FALSE, CPLOT_BLACK))
			return FALSE;
		ypos -= P->mStatsValueHeight;
		if (!CPLOT_DrawString(P, "Mean", xpos, ypos, TRUE, FALSE, CPLOT_BLACK))
			return FALSE;
		ypos -= P->mStatsValueHeight;
		if (!CPLOT_DrawString(P, "RMS", xpos, ypos, TRUE, FALSE, CPLOT_BLACK))
			return FALSE;
		ypos -= P->mStatsValueHeight;
		if (!CPLOT_DrawString(P, "\\sigma", xpos, ypos, TRUE, FALSE, CPLOT_BLACK))
			return FALSE;


		xoffset = P->mRightYLabelAllowance + 37;
		switch (P->mSeriesIndex)
		{
		case 0:
		case 1:
		case 2:
			xpos = P->mAxes.FinishX + xoffset + P->mSeriesIndex*P->mLabelWidth;
			ypos = P->mAxes.FinishY - 6;
			break;
		case 3:
		case 4:
		case 5:
			xpos = P->mAxes.FinishX + xoffset + (P->mSeriesIndex - 3)*P->mLabelWidth;
			ypos = P->mAxes.FinishY - 6 - (P->mSeriesIndex / 3)*(P->mStatsValueHeight * 8);
			break;
		case 6:
		case 7:
		case 8:
			xpos = P->mAxes.FinishX + xoffset + (P->mSeriesIndex - 6)*P->mLabelWidth;
			ypos = P->mAxes.FinishY - 6 - (P->mSeriesIndex / 3)*(P->mStatsValueHeight * 8);
			break;
		case 9:
		case 10:
		case 11:
			xpos = P->mAxes.FinishX + xoffset + (P->mSeriesIndex - 9)*P->mLabelWidth;
			ypos = P->mAxes.FinishY - 6 - (P->mSeriesIndex / 3)*(P->mStatsValueHeight * 8);
			break;
		default:
			return FALSE; // no more than 12 series possible            
		}

		if (!CPLOT_DrawLine(P, xpos + P->mLabelWidth, ypos - boxheight, xpos + P->mLabelWidth, ypos, CPLOT_LIGHTGREY))
			return FALSE;
		if (!CPLOT_DrawLine(P, xpos - 2, ypos, xpos + P->mLabelWidth, ypos, CPLOT_LIGHTGREY))
			return FALSE;
		if (!CPLOT_DrawLine(P, xpos - 2, ypos - boxheight, xpos + P->mLabelWidth, ypos - boxheight, CPLOT_LIGHTGREY))
			return FALSE;

		ypos -= P->mStatsValueHeight * 2 + 5;
		for (i = 0; i < 5; i++)
		{
			if (!CPLOT_DrawLine(
				P,
				xpos - 2,
				ypos + 5 - P->mStatsValueHeight*i,
				xpos + P->mLabelWidth,
				ypos + 5 - P->mStatsValueHeight*i,
				CPLOT_LIGHTGREY))
			{
				return FALSE;
			}
		}

		xpos += 3;
		ypos += 2;
		if (!CPLOT_DrawStatsValue(P, Series->yStats.min, xpos, ypos, Series->color, Series->precision))
			return FALSE;
		ypos -= P->mStatsValueHeight;
		if (!CPLOT_DrawStatsValue(P, Series->yStats.max, xpos, ypos, Series->color, Series->precision))
			return FALSE;
		ypos -= P->mStatsValueHeight;
		if (!CPLOT_DrawStatsValue(P, Series->yStats.mean, xpos, ypos, Series->color, Series->precision))
			return FALSE;
		ypos -= P->mStatsValueHeight;
		if (!CPLOT_DrawStatsValue(P, Series->yStats.rms, xpos, ypos, Series->color, Series->precision))
			return FALSE;
		ypos -= P->mStatsValueHeight;
		if (!CPLOT_DrawStatsValue(P, Series->yStats.stdev, xpos, ypos, Series->color, Series->precision))
			return FALSE;
	}
	else
	{
		yoffset = P->mXLabelAllowance + 6;
		high = P->mAxes.StartY - yoffset;
		low = P->mAxes.StartY - yoffset - P->mStatsValueHeight;

		if (!CPLOT_DrawString(P, "Min", 200, high - 2, TRUE, FALSE, CPLOT_BLACK))
			return FALSE;
		if (!CPLOT_DrawLine(P, 6, high, 680, high, CPLOT_LIGHTGREY))
			return FALSE;
		if (!CPLOT_DrawLine(P, 197, low, 197, high, CPLOT_LIGHTGREY))
			return FALSE;

		if (!CPLOT_DrawString(P, "Max", 280, high - 2, TRUE, FALSE, CPLOT_BLACK))
			return FALSE;
		if (!CPLOT_DrawLine(P, 277, low, 277, high, CPLOT_LIGHTGREY))
			return FALSE;

		if (!CPLOT_DrawString(P, "Mean", 360, high - 2, TRUE, FALSE, CPLOT_BLACK))
			return FALSE;
		if (!CPLOT_DrawLine(P, 357, low, 357, high, CPLOT_LIGHTGREY))
			return FALSE;

		if (!CPLOT_DrawString(P, "RMS", 440, high - 2, TRUE, FALSE, CPLOT_BLACK))
			return FALSE;
		if (!CPLOT_DrawLine(P, 437, low, 437, high, CPLOT_LIGHTGREY))
			return FALSE;

		if (!CPLOT_DrawString(P, "\\sigma", 520, high - 2, TRUE, FALSE, CPLOT_BLACK))
			return FALSE;
		if (!CPLOT_DrawLine(P, 517, low, 517, high, CPLOT_LIGHTGREY))
			return FALSE;

		//if( !CPLOT_DrawString( P, "Units",  600, high-2, TRUE, FALSE, CPLOT_BLACK ) )
		//  return FALSE;
		if (!CPLOT_DrawLine(P, 597, low, 597, high, CPLOT_LIGHTGREY))
			return FALSE;

		if (!CPLOT_DrawLine(P, 6, P->mAxes.StartY - yoffset - P->mStatsValueHeight, 680, P->mAxes.StartY - yoffset - P->mStatsValueHeight, CPLOT_LIGHTGREY))
			return FALSE;
		if (!CPLOT_DrawLine(P, 6, P->mAxes.StartY - yoffset - P->mStatsValueHeight, 6, P->mAxes.StartY - yoffset, CPLOT_LIGHTGREY))
			return FALSE;
		if (!CPLOT_DrawLine(P, 680, P->mAxes.StartY - yoffset - P->mStatsValueHeight, 680, P->mAxes.StartY - yoffset, CPLOT_LIGHTGREY))
			return FALSE;

		ypos = P->mAxes.StartY - yoffset - P->mStatsValueHeight*(P->mSeriesIndex + 2);

		if (!CPLOT_DrawLine(P, 6, ypos, 680, ypos, CPLOT_LIGHTGREY))
			return FALSE;
		if (!CPLOT_DrawLine(P, 6, ypos, 6, ypos + P->mStatsValueHeight, CPLOT_LIGHTGREY))
			return FALSE;
		if (!CPLOT_DrawLine(P, 197, ypos, 197, ypos + P->mStatsValueHeight, CPLOT_LIGHTGREY))
			return FALSE;
		if (!CPLOT_DrawLine(P, 277, ypos, 277, ypos + P->mStatsValueHeight, CPLOT_LIGHTGREY))
			return FALSE;
		if (!CPLOT_DrawLine(P, 357, ypos, 357, ypos + P->mStatsValueHeight, CPLOT_LIGHTGREY))
			return FALSE;
		if (!CPLOT_DrawLine(P, 437, ypos, 437, ypos + P->mStatsValueHeight, CPLOT_LIGHTGREY))
			return FALSE;
		if (!CPLOT_DrawLine(P, 517, ypos, 517, ypos + P->mStatsValueHeight, CPLOT_LIGHTGREY))
			return FALSE;
		if (!CPLOT_DrawLine(P, 597, ypos, 597, ypos + P->mStatsValueHeight, CPLOT_LIGHTGREY))
			return FALSE;
		if (!CPLOT_DrawLine(P, 680, ypos, 680, ypos + P->mStatsValueHeight, CPLOT_LIGHTGREY))
			return FALSE;

		ypos = P->mAxes.StartY - yoffset - 2 - P->mStatsValueHeight*(P->mSeriesIndex + 1);

		if (!CPLOT_DrawStatsValue(P, Series->yStats.min, 200, ypos, Series->color, Series->precision))
			return FALSE;
		if (!CPLOT_DrawStatsValue(P, Series->yStats.max, 280, ypos, Series->color, Series->precision))
			return FALSE;
		if (!CPLOT_DrawStatsValue(P, Series->yStats.mean, 360, ypos, Series->color, Series->precision))
			return FALSE;
		if (!CPLOT_DrawStatsValue(P, Series->yStats.rms, 440, ypos, Series->color, Series->precision))
			return FALSE;
		if (!CPLOT_DrawStatsValue(P, Series->yStats.stdev, 520, ypos, Series->color, Series->precision))
			return FALSE;

	}
	return TRUE;
}




BOOL CPLOT_FWriteRGB(FILE* out, CPLOT_structRGB val)
{
	if (!out)
		return FALSE;
	fwrite(&val.Blue, sizeof(byte), 1, out);
	fwrite(&val.Green, sizeof(byte), 1, out);
	fwrite(&val.Red, sizeof(byte), 1, out);
	fwrite(&val.Reserved, sizeof(byte), 1, out);
	return TRUE;
}


/** \brief  The BITMAP file header struct.

\code
start    size    name       stdvalue    purpose
1        2       Type       19778       must always be set to 'BM' to declare that this is a .bmp-file.
3        4       Size       ??          specifies the size of the file in bytes.
7        2       Reserved1  0           must always be set to zero.
9        2       Reserved2  0           must always be set to zero.
11       4       OffBits    1078        specifies the offset from the beginning of the file to the bitmap data.
\endcode
*/
typedef struct
{
	unsigned short  Type;                 // must be BM //0x4D42
	unsigned long   Size;                 // size in bytes of the file
	unsigned short  Reserved1;            // 0
	unsigned short  Reserved2;            // 0
	unsigned long   OffsetToBitmapBits;   // offset in bytes from BitmapFileHeader to bitmap bits
} CPLOT_structBitmapFileHeader;


/** \brief  The BITMAP file info struct.

\code
start    size    name            stdvalue  purpose
15       4       Size            40        specifies the size of the BITMAPINFOHEADER structure, in bytes.
19       4       Width           100       specifies the width of the image, in pixels.
23       4       Height          100       specifies the height of the image, in pixels.
27       2       Planes          1         specifies the number of planes of the target device, must be set to zero.
29       2       BitCount        8         specifies the number of bits per pixel.
31       4       Compression     0         Specifies the type of compression, usually set to zero (no compression).
35       4       SizeImage       0         specifies the size of the image data, in bytes. If there is no compression, it is valid to set this member to zero.
39       4       XPelsPerMeter   0         specifies the the horizontal pixels per meter on the designated targer device, usually set to zero.
43       4       YPelsPerMeter   0         specifies the the vertical pixels per meter on the designated targer device, usually set to zero.
47       4       ClrUsed         0         specifies the number of colors used in the bitmap, if set to zero the number of colors is calculated using the biBitCount member.
51       4       ClrImportant    0         specifies the number of color that are 'important' for the bitmap, if set to zero, all colors are important.
\endcode
*/
typedef struct
{
	unsigned long   Size; // size of the stBitmapInfoHeader (does not include the color table)
	long            Width;
	long            Height;
	unsigned short  Planes;
	unsigned short  BitCount;
	unsigned long   Compression;
	unsigned long   SizeImage;
	long            XPelsPerMeter;
	long            YPelsPerMeter;
	unsigned long   ClrUsed;
	unsigned long   ClrImportant;
} CPLOT_structBitmapInfoHeader;


BOOL CPLOT_SaveToFile(
	CPLOT *P,
	const char *FileName
)
{
	int i = 0,
		j = 0,
		z = 0,
		count = 0,
		sizeOfColorTable = 0;
	int max_z;

	unsigned compressedSize = 0;

	BOOL first = TRUE;

	byte theByte = 0;
	byte last = 0;

	CPLOT_structByteMatrix CompressedVector;

	FILE* BmpFile = NULL;

	CPLOT_structBitmapFileHeader BitmapFileHeader;
	CPLOT_structBitmapInfoHeader BitmapInfoHeader;

	CPLOT_BYTE_MTX_Init(&CompressedVector);

	// the image width must be divisible by four
	if (P->mImage.Width % 4 != 0)
		return FALSE;

	memset(&BitmapFileHeader, 0, sizeof(CPLOT_structBitmapFileHeader)); // don't use preprocesso constants here
	memset(&BitmapInfoHeader, 0, sizeof(CPLOT_structBitmapInfoHeader)); // don't use preprocesso constants here

	BitmapFileHeader.Type = 0x4D42; //BM

									// assuming the default color table
	BitmapFileHeader.Size = P->mImage.Width*P->mImage.Height +
		CPLOT_SIZEOF_BITMAPFILEHEADER +
		CPLOT_SIZEOF_BITMAPINFOHEADER +
		sizeof(CPLOT_structColorTable); // 22*4, works for 1,2,4,8 byte packing

	BitmapFileHeader.Reserved1 = 0;
	BitmapFileHeader.Reserved2 = 0;
	BitmapFileHeader.OffsetToBitmapBits = 0; // set later

	BitmapInfoHeader.Size = CPLOT_SIZEOF_BITMAPINFOHEADER;
	BitmapInfoHeader.Width = P->mImage.Width;  // pixels
	BitmapInfoHeader.Height = P->mImage.Height; // pixels
	BitmapInfoHeader.Planes = 1;
	BitmapInfoHeader.BitCount = 8;
	BitmapInfoHeader.Compression = 0; // set later
	BitmapInfoHeader.SizeImage = P->mImage.Width*P->mImage.Height;
	BitmapInfoHeader.XPelsPerMeter = 0;
	BitmapInfoHeader.YPelsPerMeter = 0;
	BitmapInfoHeader.ClrUsed = 22;
	BitmapInfoHeader.ClrImportant = 22;


	// compress bitmap using RLE encoding
	// possible to be larger than original, so we'll overallocate by 2  
	max_z = BitmapInfoHeader.SizeImage * 2;
	if (max_z > 41943040) // about 40 MB 
		return FALSE;
	CPLOT_BYTE_MTX_calloc(&CompressedVector, 1, max_z);

	// place 2d byte matrix into a vector
	for (i = 0; i < (int)P->mPlotData.nrows; i++)
	{
		count = 0;
		first = TRUE;
		for (j = 0; j < (int)P->mPlotData.ncols; j++)
		{
			theByte = P->mPlotData.data[i][j];

			if (first)
			{
				last = theByte;
				count = 1;
				first = FALSE;
				continue;
			}

			if (count == 255)
			{
				CompressedVector.data[0][z] = count;
				z++;
				if (z >= max_z)
				{
					CPLOT_BYTE_MTX_Free(&CompressedVector);
					return FALSE;
				}
				CompressedVector.data[0][z] = last;
				z++;
				if (z >= max_z)
				{
					CPLOT_BYTE_MTX_Free(&CompressedVector);
					return FALSE;
				}
				first = TRUE;
				count = 0;
				j--;
				continue;
			}

			if (theByte == last)
			{
				count++;
			}
			else
			{
				CompressedVector.data[0][z] = count;
				z++;
				if (z >= max_z)
				{
					CPLOT_BYTE_MTX_Free(&CompressedVector);
					return FALSE;
				}
				CompressedVector.data[0][z] = last;
				z++;
				if (z >= max_z)
				{
					CPLOT_BYTE_MTX_Free(&CompressedVector);
					return FALSE;
				}
				count = 1;
				last = theByte;
			}
		}
		if (count != 0)
		{
			CompressedVector.data[0][z] = count;
			z++;
			if (z >= max_z)
			{
				CPLOT_BYTE_MTX_Free(&CompressedVector);
				return FALSE;
			}
			CompressedVector.data[0][z] = last;
			z++;
			if (z >= max_z)
			{
				CPLOT_BYTE_MTX_Free(&CompressedVector);
				return FALSE;
			}
		}
		if (i != (int)(P->mPlotData.nrows - 1))
		{
			CompressedVector.data[0][z] = 0;
			z++;
			if (z >= max_z)
			{
				CPLOT_BYTE_MTX_Free(&CompressedVector);
				return FALSE;
			}
			CompressedVector.data[0][z] = 0;
			z++;
			if (z >= max_z)
			{
				CPLOT_BYTE_MTX_Free(&CompressedVector);
				return FALSE;
			}
		}
	}

	// indicate end of bitmap
	CompressedVector.data[0][z] = 0;
	z++;
	if (z >= max_z)
	{
		CPLOT_BYTE_MTX_Free(&CompressedVector);
		return FALSE;
	}
	CompressedVector.data[0][z] = 1;
	z++;
	if (z >= max_z)
	{
		CPLOT_BYTE_MTX_Free(&CompressedVector);
		return FALSE;
	}
	compressedSize = z;

	sizeOfColorTable = BitmapInfoHeader.ClrUsed * 4;
	BitmapFileHeader.OffsetToBitmapBits = CPLOT_SIZEOF_BITMAPFILEHEADER + CPLOT_SIZEOF_BITMAPINFOHEADER + sizeOfColorTable; // 14 + 40 + 88

																															// check that compressed is better
	if (compressedSize < BitmapInfoHeader.SizeImage)
	{
		BitmapInfoHeader.Compression = 1;
		BitmapInfoHeader.SizeImage = compressedSize;
		BitmapFileHeader.Size = compressedSize + BitmapFileHeader.OffsetToBitmapBits;
	}

#ifndef _CRT_SECURE_NO_DEPRECATE
	if (fopen_s(&BmpFile, FileName, "wb") != 0)
	{
		CPLOT_BYTE_MTX_Free(&CompressedVector);
		return FALSE;
	}
#else
	BmpFile = fopen(FileName, "wb");
	if (!BmpFile)
	{
		CPLOT_BYTE_MTX_Free(&CompressedVector);
		return FALSE;
	}
#endif

	// write the header, write basic element at a time to avoid struct member packing issues.
	fwrite(&BitmapFileHeader.Type, sizeof(BitmapFileHeader.Type), 1, BmpFile);
	fwrite(&BitmapFileHeader.Size, sizeof(BitmapFileHeader.Size), 1, BmpFile);
	fwrite(&BitmapFileHeader.Reserved1, sizeof(BitmapFileHeader.Reserved1), 1, BmpFile);
	fwrite(&BitmapFileHeader.Reserved2, sizeof(BitmapFileHeader.Reserved2), 1, BmpFile);
	fwrite(&BitmapFileHeader.OffsetToBitmapBits, sizeof(BitmapFileHeader.OffsetToBitmapBits), 1, BmpFile);

	fwrite(&BitmapInfoHeader.Size, sizeof(BitmapInfoHeader.Size), 1, BmpFile);
	fwrite(&BitmapInfoHeader.Width, sizeof(BitmapInfoHeader.Width), 1, BmpFile);
	fwrite(&BitmapInfoHeader.Height, sizeof(BitmapInfoHeader.Height), 1, BmpFile);
	fwrite(&BitmapInfoHeader.Planes, sizeof(BitmapInfoHeader.Planes), 1, BmpFile);
	fwrite(&BitmapInfoHeader.BitCount, sizeof(BitmapInfoHeader.BitCount), 1, BmpFile);
	fwrite(&BitmapInfoHeader.Compression, sizeof(BitmapInfoHeader.Compression), 1, BmpFile);
	fwrite(&BitmapInfoHeader.SizeImage, sizeof(BitmapInfoHeader.SizeImage), 1, BmpFile);
	fwrite(&BitmapInfoHeader.XPelsPerMeter, sizeof(BitmapInfoHeader.XPelsPerMeter), 1, BmpFile);
	fwrite(&BitmapInfoHeader.YPelsPerMeter, sizeof(BitmapInfoHeader.YPelsPerMeter), 1, BmpFile);
	fwrite(&BitmapInfoHeader.ClrUsed, sizeof(BitmapInfoHeader.ClrUsed), 1, BmpFile);
	fwrite(&BitmapInfoHeader.ClrImportant, sizeof(BitmapInfoHeader.ClrImportant), 1, BmpFile);


	if (P->mUseDefaultColorTable)
	{
		CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.White);
		CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.Black);
		CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.Blue);
		CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.Green);
		CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.Purple);
		CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.Magenta);
		CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.DarkBlue);
		CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.IndianRed);
		CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.BabyBlue);
		CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.PaislyBlue);
		CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.LightPurple);
		CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.DarkPurple);
		CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.GreyPurple);
		CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.Brown);
		CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.Red);
		CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.Pink);
		CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.Yellow);
		CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.Orange);
		CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.Cyan);
		CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.LimeGreen);
		CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.Grey);
		CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.LightGrey);
	}
	else
	{
		if (P->mColorTable)
		{
			for (i = 0; i < sizeOfColorTable; i++)
				fwrite(&(P->mColorTable[i]), sizeof(unsigned char), 1, BmpFile);
		}
		else
		{
			CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.White);
			CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.Black);
			CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.Blue);
			CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.Green);
			CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.Purple);
			CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.Magenta);
			CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.DarkBlue);
			CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.IndianRed);
			CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.BabyBlue);
			CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.PaislyBlue);
			CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.LightPurple);
			CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.DarkPurple);
			CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.GreyPurple);
			CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.Brown);
			CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.Red);
			CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.Pink);
			CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.Yellow);
			CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.Orange);
			CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.Cyan);
			CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.LimeGreen);
			CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.Grey);
			CPLOT_FWriteRGB(BmpFile, P->mDefaultColorTable.LightGrey);
		}
	}


	if (BitmapInfoHeader.Compression == 1)
	{
		if (fwrite(CompressedVector.data[0], sizeof(byte), compressedSize, BmpFile) != compressedSize)
		{
			CPLOT_BYTE_MTX_Free(&CompressedVector);
			return FALSE;
		}
		// done
	}
	else
	{
		for (i = 0; i < (int)P->mPlotData.nrows; i++)
		{
			// write the mPlotData
			if (fwrite(P->mPlotData.data[i], sizeof(byte), P->mPlotData.ncols, BmpFile) != P->mPlotData.ncols)
			{
				CPLOT_BYTE_MTX_Free(&CompressedVector);
				return FALSE;
			}
		}
	}

	fclose(BmpFile);

	CPLOT_BYTE_MTX_Free(&CompressedVector);
	return TRUE;
}






BOOL CPLOT_SetPlotOptions(
	CPLOT *P,
	CPLOT_structPlotOptions *opt
)
{
	if (!P)
		return FALSE;
	if (!opt)
		return FALSE;

	memcpy(&(P->mOptions), opt, sizeof(CPLOT_structPlotOptions));
	return TRUE;
}



BOOL CPLOT_Plot(
	CPLOT *P,
	CPLOT_structSeries *Series
)
{
	int i = 0;
	int x1 = 0;
	int x2 = 0;
	int y1 = 0;
	int y2 = 0;
	int n = 0;

	double xval_i;
	double xval_ip1;
	double yval_i;
	double yval_ip1;
	CPLOT_enumColor color;

	if (!P)
		return FALSE;
	if (!Series)
		return FALSE;
	if (!Series->X)
		return FALSE;
	if (!Series->Y)
		return FALSE;

	n = Series->n;

	if (!CPLOT_DetermineSeriesStatistics(Series))
		return FALSE;

	if (!P->mIsAxesDrawn || P->mOptions.redrawAxes)
	{
		// draw the axes
		if (!CPLOT_DrawAxes(P, Series, CPLOT_BLACK))
			return FALSE;
		P->mIsAxesDrawn = TRUE;
	}

	if (P->mOptions.numberOfSeries < P->mSeriesIndex + 1)
	{
		P->mOptions.numberOfSeries = P->mSeriesIndex + 1;
		if (P->mOptions.numberOfSeries <= 3)
		{
			if (!CPLOT_ResizePlot(P))
				return FALSE;
		}
	}


	// now plot the mPlotData   
	for (i = 0; i < n; i++)
	{
		xval_i = Series->X[i];
		yval_i = Series->Y[i];

		if (CPLOT_IsNAN(xval_i))
			continue;
		if (CPLOT_IsNAN(yval_i))
			continue;

		if (xval_i < P->mData.MinX)
			continue;
		if (xval_i > P->mData.MaxX)
			continue;

		x1 = (int)((xval_i - P->mData.MinX)*P->mData.ScaleX) + P->mAxes.StartX;
		y1 = (int)((yval_i - P->mData.MinY)*P->mData.ScaleY) + P->mAxes.StartY;

		if (i == n - 1)
		{
			xval_ip1 = xval_i;
			yval_ip1 = yval_i;
			x2 = x1;
			y2 = y1;
		}
		else
		{
			xval_ip1 = Series->X[i + 1];
			yval_ip1 = Series->Y[i + 1];
			if (CPLOT_IsNAN(xval_ip1))
			{
				xval_ip1 = xval_i;
				yval_ip1 = yval_i;
				x2 = x1;
				y2 = y1;
			}
			else if (CPLOT_IsNAN(yval_ip1))
			{
				xval_ip1 = xval_i;
				yval_ip1 = yval_i;
				x2 = x1;
				y2 = y1;
			}
			else
			{
				x2 = (int)((xval_ip1 - P->mData.MinX)*P->mData.ScaleX) + P->mAxes.StartX;
				y2 = (int)((yval_ip1 - P->mData.MinY)*P->mData.ScaleY) + P->mAxes.StartY;
			}
		}

		color = Series->color;

		if (x1 <= P->mAxes.StartX - 2)
		{
			continue;
		}
		if (x1 >= P->mAxes.FinishX + 2)
		{
			continue;
		}
		if (y1 <= P->mAxes.StartY - 2)
		{
			if (Series->markOutlierData)
			{
				// watch for +infinity values.
				if (CPLOT_IsPostiveINF(yval_i))
				{
					y1 = P->mAxes.FinishY + 2;
					if (i == n - 1) // last point 
					{
						y2 = P->mAxes.FinishY;
					}
				}
				else
				{
					y1 = P->mAxes.StartY - 2;
					if (i == n - 1) // last point 
					{
						y2 = P->mAxes.StartY;
					}
				}
				color = CPLOT_CYAN;
			}
			else
			{
				continue;
			}
		}
		if (y1 >= P->mAxes.FinishY + 2)
		{
			if (Series->markOutlierData)
			{
				// watch for -infinity values.
				if (CPLOT_IsNegativeINF(yval_i))
				{
					y1 = P->mAxes.StartY - 2;
					if (i == n - 1) // last point 
					{
						y2 = P->mAxes.StartY;
					}
				}
				else
				{
					y1 = P->mAxes.FinishY + 2;
					if (i == n - 1) // last point 
					{
						y2 = P->mAxes.FinishY;
					}
				}
				color = CPLOT_CYAN;
			}
			else
			{
				continue;
			}
		}

		if (xval_i < P->mOptions.endOfWarmupEpoch)
		{
			if (!CPLOT_DrawPoint(P, x1, y1, CPLOT_LIGHTGREY))
				return FALSE;
		}
		else
		{
			if (!CPLOT_DrawPoint(P, x1, y1, color))
				return FALSE;
		}

		if (x2 < P->mAxes.StartX)
		{
			if (CPLOT_IsPostiveINF(xval_ip1))
			{
				x2 = P->mAxes.FinishX;
			}
			else
			{
				x2 = P->mAxes.StartX;
			}
		}

		if (x2 > P->mAxes.FinishX)
		{
			if (CPLOT_IsNegativeINF(xval_ip1))
			{
				x2 = P->mAxes.StartX;
			}
			else
			{
				x2 = P->mAxes.FinishX;
			}
		}

		if (y2 < P->mAxes.StartY)
		{
			if (CPLOT_IsPostiveINF(yval_ip1))
			{
				y2 = P->mAxes.FinishY;
			}
			else
			{
				y2 = P->mAxes.StartY;
			}
		}

		if (y2 > P->mAxes.FinishY)
		{
			if (CPLOT_IsNegativeINF(yval_ip1))
			{
				y2 = P->mAxes.StartY;
			}
			else
			{
				y2 = P->mAxes.FinishY;
			}
		}

		if (Series->connected)
		{
			if (xval_i < P->mOptions.endOfWarmupEpoch)
			{
				if (!CPLOT_DrawLine(P, x1, y1, x2, y2, CPLOT_LIGHTGREY))
					return FALSE;
			}
			else
			{
				if (!CPLOT_DrawLine(P, x1, y1, x2, y2, Series->color))
					return FALSE;
			}
		}
	}

	if (Series->label != NULL)
	{
		if (strlen(Series->label) > 0)
		{
			if (!CPLOT_DrawLegendLabel(P, Series->label, Series->units, Series->color))
				return FALSE;
		}
	}

	if (P->mOptions.plotStatistics)
	{
		if (!CPLOT_DrawStats(P, Series))
			return FALSE;
	}

	P->mSeriesIndex++;
	return TRUE;
}


