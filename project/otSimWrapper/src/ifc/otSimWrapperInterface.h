#pragma once

#ifndef __INTERGEN_GENERATED__otSimWrapperInterface_H__
#define __INTERGEN_GENERATED__otSimWrapperInterface_H__

//@file Interface file for otSimWrapperInterface interface generated by intergen
//See LICENSE file for copyright and license information

#include <comm/commexception.h>
#include <comm/intergen/ifc.h>

#ifndef OT_SIM_WRAPPER_HPP
#include <ot/vehicle_physics.h>
#include <ot/aircraft_physics.h>
#include <ot/environment.h>
//#include <ot/logger.h>
#endif

namespace otsim_wrapper {
    class otSimWrapper;
}

namespace sf {

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////

////////////////////////////////////
///[namespace::]name, path
class otSimWrapperInterface
    : public intergen_interface
{
public:

    // --- interface methods ---

    ///////////////
    
    ///////////////
    ///Update simulation (global)
    void updateSimulation( float dt );

    ///Update physics (global)
    void updatePhysics( float dt );

    ///////////////////
    
    ///////////////////
    
    void set_time_of_day( double timeOfDay );

    void set_timeflow_multiplier( float timeAccel = 1.f );

    void set_day_of_year( int dayOfYear );

    ///////////////////
    
    ///////////////////
    
    double get_time_of_day();

    float get_timeflow_multiplier();

    int get_day_of_year();

    // --- creators ---

    ////////////////////////////////
    
    ////////////////////////////////
    static iref<otSimWrapperInterface> get() {
        return get<otSimWrapperInterface>(0);
    }

    template<class T>
    static iref<T> get( T* _subclass_ );

    // --- internal helpers ---

    static const int HASHID = 2851289527;

    int intergen_hash_id() const override final { return HASHID; }

    bool iface_is_derived( int hash ) const override final {
        return hash == HASHID;
    }

    const coid::tokenhash& intergen_interface_name() const override final {
        static const coid::tokenhash _name = "sf::otSimWrapperInterface";
        return _name;
    }

    static const coid::token& intergen_default_creator_static( EBackend bck ) {
        static const coid::token _dc("sf::otSimWrapperInterface.get@2851289527");
        static const coid::token _djs("sf::otSimWrapperInterface@wrapper.js");
        static const coid::token _dlua("sf::otSimWrapperInterface@wrapper.lua");
        static const coid::token _dnone;

        switch(bck) {
        case IFC_BACKEND_CXX: return _dc;
        case IFC_BACKEND_JS:  return _djs;
        case IFC_BACKEND_LUA: return _dlua;
        default: return _dnone;
        }
    }


    template<enum EBackend B>
    static void* intergen_wrapper_cache() {
        static void* _cached_wrapper=0;
        if (!_cached_wrapper) {
            const coid::token& tok = intergen_default_creator_static(B);
            _cached_wrapper = coid::interface_register::get_interface_creator(tok);
        }
        return _cached_wrapper;
    }

    void* intergen_wrapper( EBackend bck ) const override final {
        switch(bck) {
        case IFC_BACKEND_JS: return intergen_wrapper_cache<IFC_BACKEND_JS>();
        case IFC_BACKEND_LUA: return intergen_wrapper_cache<IFC_BACKEND_LUA>();
        default: return 0;
        }
    }

    EBackend intergen_backend() const override { return IFC_BACKEND_CXX; }

    const coid::token& intergen_default_creator( EBackend bck ) const override final {
        return intergen_default_creator_static(bck);
    }

    ///Client registrator
    template<class C>
    static int register_client()
    {
        static_assert(std::is_base_of<otSimWrapperInterface, C>::value, "not a base class");

        typedef iref<intergen_interface> (*fn_client)(void*, intergen_interface*);
        fn_client cc = [](void*, intergen_interface*) -> iref<intergen_interface> { return new C; };

        coid::token type = typeid(C).name();
        type.consume("class ");
        type.consume("struct ");

        coid::charstr tmp = "sf::otSimWrapperInterface";
        tmp << "@client" << '.' << type;
        
        coid::interface_register::register_interface_creator(tmp, cc);
        return 0;
    }

protected:

    otSimWrapperInterface()
    {}
};

////////////////////////////////////////////////////////////////////////////////
template<class T>
inline iref<T> otSimWrapperInterface::get( T* _subclass_ )
{
    typedef iref<T> (*fn_creator)(otSimWrapperInterface*);

    static fn_creator create = 0;
    static const coid::token ifckey = "sf::otSimWrapperInterface.get@2851289527";

    if (!create)
        create = reinterpret_cast<fn_creator>(
            coid::interface_register::get_interface_creator(ifckey));

    if (!create)
        throw coid::exception("interface creator inaccessible: ") << ifckey;

    return create(_subclass_);
}

#pragma warning(push)
#pragma warning(disable : 4191)

inline void otSimWrapperInterface::updateSimulation( float dt )
{ return VT_CALL(void,(float),0)(dt); }

inline void otSimWrapperInterface::updatePhysics( float dt )
{ return VT_CALL(void,(float),1)(dt); }

inline void otSimWrapperInterface::set_time_of_day( double timeOfDay )
{ return VT_CALL(void,(double),2)(timeOfDay); }

inline void otSimWrapperInterface::set_timeflow_multiplier( float timeAccel )
{ return VT_CALL(void,(float),3)(timeAccel); }

inline void otSimWrapperInterface::set_day_of_year( int dayOfYear )
{ return VT_CALL(void,(int),4)(dayOfYear); }

inline double otSimWrapperInterface::get_time_of_day()
{ return VT_CALL(double,(),5)(); }

inline float otSimWrapperInterface::get_timeflow_multiplier()
{ return VT_CALL(float,(),6)(); }

inline int otSimWrapperInterface::get_day_of_year()
{ return VT_CALL(int,(),7)(); }

#pragma warning(pop)

} //namespace

#endif //__INTERGEN_GENERATED__otSimWrapperInterface_H__
