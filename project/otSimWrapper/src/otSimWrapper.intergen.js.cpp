
//@file  javascript interface dispatcher generated by intergen v6
//See LICENSE file for copyright and license information

#include <comm/metastream/metastream.h>
#include <comm/metastream/fmtstream_v8.h>
#include <comm/binstream/filestream.h>
#include <comm/binstream/binstreambuf.h>

#include "ifc/otSimWrapperInterface.js.h"

using namespace coid;

////////////////////////////////////////////////////////////////////////////////
//
// javascript handler of interface otSimWrapperInterface of class otSimWrapper
//
////////////////////////////////////////////////////////////////////////////////

namespace sf {
namespace js {

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////

////////////////////////////////////
///[namespace::]name, path
class otSimWrapperInterface_js_dispatcher
    : public ::js::interface_wrapper_base<sf::otSimWrapperInterface>
{
#ifdef V8_MAJOR_VERSION
    static void _js_release_callback(const v8::WeakCallbackInfo<void*>& data)
    {
        void* p = data.GetParameter();
        otSimWrapperInterface_js_dispatcher* ifc = static_cast<otSimWrapperInterface_js_dispatcher*>(p);
        ifc->_object.Empty();
        ifc->release_refcount();
    }

#else

    static void _js_release_callback(v8::Persistent<v8::Value> object, void* p)
    {
        otSimWrapperInterface_js_dispatcher* ifc = static_cast<otSimWrapperInterface_js_dispatcher*>(p);
        DASSERT( ifc->_object == object );
        ifc->_object.Clear();
        ifc->release_refcount();

        object.Dispose();
    }
#endif

protected:

    EBackend intergen_backend() const override { return IFC_BACKEND_JS; }

public:

    v8::Handle<v8::Object> create_interface_object( v8::Handle<v8::Context> context, bool make_weak );

    static v8::Handle<v8::Script> load_script( const coid::token& scriptfile, const coid::token& file_name );

    COIDNEWDELETE("sf::otSimWrapperInterface_js_dispatcher");

    otSimWrapperInterface_js_dispatcher()
    {}

    explicit otSimWrapperInterface_js_dispatcher( sf::otSimWrapperInterface* orig ) {
        _base.create(orig);
        _vtable = _base->vtable();
        //V8_PERSISTENT(v8::Isolate::GetCurrent(), _context, context);

		_host = _base->host<policy_intrusive_base>();
    }

    void set_host( policy_intrusive_base* host ) {
        _host = host;
    }

    ~otSimWrapperInterface_js_dispatcher() {
        V8_RESET(_object);

        //V8_RESET(_script);
        //V8_RESET(_context);
    }

    bool intergen_bind_capture( coid::binstring* capture, uint instid ) override
    {
        return _real()->intergen_bind_capture(capture, instid);
    }

    void intergen_capture_dispatch( uint mid, coid::binstring& bin ) override
    {
        _real()->intergen_capture_dispatch(mid, bin);
    }

    // --- creators ---

    ////////////////////////////////
    
    ////////////////////////////////
    static iref<otSimWrapperInterface_js_dispatcher> get( const script_handle& scriptpath, const coid::token& bindname, v8::Handle<v8::Context>* );

    static v8::Handle<v8::Value> v8creator_get0(const v8::ARGUMENTS& args, interface_context* ifc);

    ///Handler for generic $query_interface javascript method
    static v8::CBK_RET v8query_interface( const v8::ARGUMENTS& args );
    static v8::CBK_RET v8query_interface_global( const v8::ARGUMENTS& args );
    static v8::CBK_RET v8log( const v8::ARGUMENTS& args );
    static v8::CBK_RET v8rebind_events( const v8::ARGUMENTS& args );
    static v8::CBK_RET v8current_global( const v8::ARGUMENTS& args );

    // --- method wrappers ---

    static v8::CBK_RET v8_updateSimulation0( const v8::ARGUMENTS& args );
    static v8::CBK_RET v8_updatePhysics1( const v8::ARGUMENTS& args );
    static v8::CBK_RET v8_set_time_of_day2( const v8::ARGUMENTS& args );
    static v8::CBK_RET v8_set_timeflow_multiplier3( const v8::ARGUMENTS& args );
    static v8::CBK_RET v8_set_day_of_year4( const v8::ARGUMENTS& args );
    static v8::CBK_RET v8_get_time_of_day5( const v8::ARGUMENTS& args );
    static v8::CBK_RET v8_get_timeflow_multiplier6( const v8::ARGUMENTS& args );
    static v8::CBK_RET v8_get_day_of_year7( const v8::ARGUMENTS& args );
};

////////////////////////////////////////////////////////////////////////////////
v8::CBK_RET otSimWrapperInterface_js_dispatcher::v8_updateSimulation0( const v8::ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    if (args.Length() < 1 || args.Length() > 1) { //in/inout arguments
        coid::charstr tmp = "Wrong number of arguments in ";
        tmp << "otSimWrapperInterface.updateSimulation";
        return v8::throw_js(iso, v8::Exception::SyntaxError, tmp);
    }

    V8_ESCAPABLE_SCOPE(iso, handle_scope__);
    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return V8_RETURN(args, V8_UNDEFINED);

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return V8_RETURN(args, V8_UNDEFINED);

    ::js::interface_wrapper_base<sf::otSimWrapperInterface>* ifc = static_cast<::js::interface_wrapper_base<sf::otSimWrapperInterface>*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    auto R_ = ifc ? ifc->_real() : 0;
    if (!R_) {
        coid::charstr tmp = "Null interface object in ";
        tmp << "otSimWrapperInterface.updateSimulation";
        return v8::throw_js(iso, &v8::Exception::ReferenceError, tmp);
    }

    v8::Context::Scope context_scope(ifc->context(iso));

    try {
    THREAD_SINGLETON(v8_streamer_context).reset();

    //stream the arguments in
    static_assert(CHECK::meta_operator_exists<float>::value, "missing metastream operator 'float'");

    threadcached<float> dt;
    from_v8(args[0], dt);

    //invoke
    R_->updateSimulation(dt);

    //stream out
    v8::Handle<v8::Object> r__;

#ifdef V8_MAJOR_VERSION
    args.GetReturnValue().Set(r__);
#else
    return V8_ESCAPE(handle_scope__, r__);
#endif

    } catch(const coid::exception& e) {
        return v8::throw_js(iso, &v8::Exception::TypeError, e.text());
    }
}

////////////////////////////////////////////////////////////////////////////////
v8::CBK_RET otSimWrapperInterface_js_dispatcher::v8_updatePhysics1( const v8::ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    if (args.Length() < 1 || args.Length() > 1) { //in/inout arguments
        coid::charstr tmp = "Wrong number of arguments in ";
        tmp << "otSimWrapperInterface.updatePhysics";
        return v8::throw_js(iso, v8::Exception::SyntaxError, tmp);
    }

    V8_ESCAPABLE_SCOPE(iso, handle_scope__);
    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return V8_RETURN(args, V8_UNDEFINED);

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return V8_RETURN(args, V8_UNDEFINED);

    ::js::interface_wrapper_base<sf::otSimWrapperInterface>* ifc = static_cast<::js::interface_wrapper_base<sf::otSimWrapperInterface>*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    auto R_ = ifc ? ifc->_real() : 0;
    if (!R_) {
        coid::charstr tmp = "Null interface object in ";
        tmp << "otSimWrapperInterface.updatePhysics";
        return v8::throw_js(iso, &v8::Exception::ReferenceError, tmp);
    }

    v8::Context::Scope context_scope(ifc->context(iso));

    try {
    THREAD_SINGLETON(v8_streamer_context).reset();

    //stream the arguments in
    static_assert(CHECK::meta_operator_exists<float>::value, "missing metastream operator 'float'");

    threadcached<float> dt;
    from_v8(args[0], dt);

    //invoke
    R_->updatePhysics(dt);

    //stream out
    v8::Handle<v8::Object> r__;

#ifdef V8_MAJOR_VERSION
    args.GetReturnValue().Set(r__);
#else
    return V8_ESCAPE(handle_scope__, r__);
#endif

    } catch(const coid::exception& e) {
        return v8::throw_js(iso, &v8::Exception::TypeError, e.text());
    }
}

////////////////////////////////////////////////////////////////////////////////
v8::CBK_RET otSimWrapperInterface_js_dispatcher::v8_set_time_of_day2( const v8::ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    if (args.Length() < 1 || args.Length() > 1) { //in/inout arguments
        coid::charstr tmp = "Wrong number of arguments in ";
        tmp << "otSimWrapperInterface.set_time_of_day";
        return v8::throw_js(iso, v8::Exception::SyntaxError, tmp);
    }

    V8_ESCAPABLE_SCOPE(iso, handle_scope__);
    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return V8_RETURN(args, V8_UNDEFINED);

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return V8_RETURN(args, V8_UNDEFINED);

    ::js::interface_wrapper_base<sf::otSimWrapperInterface>* ifc = static_cast<::js::interface_wrapper_base<sf::otSimWrapperInterface>*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    auto R_ = ifc ? ifc->_real() : 0;
    if (!R_) {
        coid::charstr tmp = "Null interface object in ";
        tmp << "otSimWrapperInterface.set_time_of_day";
        return v8::throw_js(iso, &v8::Exception::ReferenceError, tmp);
    }

    v8::Context::Scope context_scope(ifc->context(iso));

    try {
    THREAD_SINGLETON(v8_streamer_context).reset();

    //stream the arguments in
    static_assert(CHECK::meta_operator_exists<double>::value, "missing metastream operator 'double'");

    threadcached<double> timeOfDay;
    from_v8(args[0], timeOfDay);

    //invoke
    R_->set_time_of_day(timeOfDay);

    //stream out
    v8::Handle<v8::Object> r__;

#ifdef V8_MAJOR_VERSION
    args.GetReturnValue().Set(r__);
#else
    return V8_ESCAPE(handle_scope__, r__);
#endif

    } catch(const coid::exception& e) {
        return v8::throw_js(iso, &v8::Exception::TypeError, e.text());
    }
}

////////////////////////////////////////////////////////////////////////////////
v8::CBK_RET otSimWrapperInterface_js_dispatcher::v8_set_timeflow_multiplier3( const v8::ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    if (args.Length() < 0 || args.Length() > 1) { //in/inout arguments
        coid::charstr tmp = "Wrong number of arguments in ";
        tmp << "otSimWrapperInterface.set_timeflow_multiplier";
        return v8::throw_js(iso, v8::Exception::SyntaxError, tmp);
    }

    V8_ESCAPABLE_SCOPE(iso, handle_scope__);
    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return V8_RETURN(args, V8_UNDEFINED);

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return V8_RETURN(args, V8_UNDEFINED);

    ::js::interface_wrapper_base<sf::otSimWrapperInterface>* ifc = static_cast<::js::interface_wrapper_base<sf::otSimWrapperInterface>*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    auto R_ = ifc ? ifc->_real() : 0;
    if (!R_) {
        coid::charstr tmp = "Null interface object in ";
        tmp << "otSimWrapperInterface.set_timeflow_multiplier";
        return v8::throw_js(iso, &v8::Exception::ReferenceError, tmp);
    }

    v8::Context::Scope context_scope(ifc->context(iso));

    try {
    THREAD_SINGLETON(v8_streamer_context).reset();

    //stream the arguments in
    static_assert(CHECK::meta_operator_exists<float>::value, "missing metastream operator 'float'");

    threadcached<float> timeAccel;
    if (0 < args.Length())
        from_v8(args[0], timeAccel);
    else
        timeAccel = 1.f;

    //invoke
    R_->set_timeflow_multiplier(timeAccel);

    //stream out
    v8::Handle<v8::Object> r__;

#ifdef V8_MAJOR_VERSION
    args.GetReturnValue().Set(r__);
#else
    return V8_ESCAPE(handle_scope__, r__);
#endif

    } catch(const coid::exception& e) {
        return v8::throw_js(iso, &v8::Exception::TypeError, e.text());
    }
}

////////////////////////////////////////////////////////////////////////////////
v8::CBK_RET otSimWrapperInterface_js_dispatcher::v8_set_day_of_year4( const v8::ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    if (args.Length() < 1 || args.Length() > 1) { //in/inout arguments
        coid::charstr tmp = "Wrong number of arguments in ";
        tmp << "otSimWrapperInterface.set_day_of_year";
        return v8::throw_js(iso, v8::Exception::SyntaxError, tmp);
    }

    V8_ESCAPABLE_SCOPE(iso, handle_scope__);
    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return V8_RETURN(args, V8_UNDEFINED);

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return V8_RETURN(args, V8_UNDEFINED);

    ::js::interface_wrapper_base<sf::otSimWrapperInterface>* ifc = static_cast<::js::interface_wrapper_base<sf::otSimWrapperInterface>*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    auto R_ = ifc ? ifc->_real() : 0;
    if (!R_) {
        coid::charstr tmp = "Null interface object in ";
        tmp << "otSimWrapperInterface.set_day_of_year";
        return v8::throw_js(iso, &v8::Exception::ReferenceError, tmp);
    }

    v8::Context::Scope context_scope(ifc->context(iso));

    try {
    THREAD_SINGLETON(v8_streamer_context).reset();

    //stream the arguments in
    static_assert(CHECK::meta_operator_exists<int>::value, "missing metastream operator 'int'");

    threadcached<int> dayOfYear;
    from_v8(args[0], dayOfYear);

    //invoke
    R_->set_day_of_year(dayOfYear);

    //stream out
    v8::Handle<v8::Object> r__;

#ifdef V8_MAJOR_VERSION
    args.GetReturnValue().Set(r__);
#else
    return V8_ESCAPE(handle_scope__, r__);
#endif

    } catch(const coid::exception& e) {
        return v8::throw_js(iso, &v8::Exception::TypeError, e.text());
    }
}

////////////////////////////////////////////////////////////////////////////////
v8::CBK_RET otSimWrapperInterface_js_dispatcher::v8_get_time_of_day5( const v8::ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    if (args.Length() < 0 || args.Length() > 0) { //in/inout arguments
        coid::charstr tmp = "Wrong number of arguments in ";
        tmp << "otSimWrapperInterface.get_time_of_day";
        return v8::throw_js(iso, v8::Exception::SyntaxError, tmp);
    }

    V8_ESCAPABLE_SCOPE(iso, handle_scope__);
    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return V8_RETURN(args, V8_UNDEFINED);

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return V8_RETURN(args, V8_UNDEFINED);

    ::js::interface_wrapper_base<sf::otSimWrapperInterface>* ifc = static_cast<::js::interface_wrapper_base<sf::otSimWrapperInterface>*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    auto R_ = ifc ? ifc->_real() : 0;
    if (!R_) {
        coid::charstr tmp = "Null interface object in ";
        tmp << "otSimWrapperInterface.get_time_of_day";
        return v8::throw_js(iso, &v8::Exception::ReferenceError, tmp);
    }

    v8::Context::Scope context_scope(ifc->context(iso));

    try {
    THREAD_SINGLETON(v8_streamer_context).reset();

    //stream the arguments in

    //invoke
    double _rval_ = R_->get_time_of_day();

    //stream out
    v8::Handle<v8::Value> r__;
    static_assert( CHECK::meta_operator_exists<double>::value, "missing metastream operator for 'double'" );
    r__ = to_v8(_rval_);

#ifdef V8_MAJOR_VERSION
    args.GetReturnValue().Set(r__);
#else
    return V8_ESCAPE(handle_scope__, r__);
#endif

    } catch(const coid::exception& e) {
        return v8::throw_js(iso, &v8::Exception::TypeError, e.text());
    }
}

////////////////////////////////////////////////////////////////////////////////
v8::CBK_RET otSimWrapperInterface_js_dispatcher::v8_get_timeflow_multiplier6( const v8::ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    if (args.Length() < 0 || args.Length() > 0) { //in/inout arguments
        coid::charstr tmp = "Wrong number of arguments in ";
        tmp << "otSimWrapperInterface.get_timeflow_multiplier";
        return v8::throw_js(iso, v8::Exception::SyntaxError, tmp);
    }

    V8_ESCAPABLE_SCOPE(iso, handle_scope__);
    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return V8_RETURN(args, V8_UNDEFINED);

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return V8_RETURN(args, V8_UNDEFINED);

    ::js::interface_wrapper_base<sf::otSimWrapperInterface>* ifc = static_cast<::js::interface_wrapper_base<sf::otSimWrapperInterface>*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    auto R_ = ifc ? ifc->_real() : 0;
    if (!R_) {
        coid::charstr tmp = "Null interface object in ";
        tmp << "otSimWrapperInterface.get_timeflow_multiplier";
        return v8::throw_js(iso, &v8::Exception::ReferenceError, tmp);
    }

    v8::Context::Scope context_scope(ifc->context(iso));

    try {
    THREAD_SINGLETON(v8_streamer_context).reset();

    //stream the arguments in

    //invoke
    float _rval_ = R_->get_timeflow_multiplier();

    //stream out
    v8::Handle<v8::Value> r__;
    static_assert( CHECK::meta_operator_exists<float>::value, "missing metastream operator for 'float'" );
    r__ = to_v8(_rval_);

#ifdef V8_MAJOR_VERSION
    args.GetReturnValue().Set(r__);
#else
    return V8_ESCAPE(handle_scope__, r__);
#endif

    } catch(const coid::exception& e) {
        return v8::throw_js(iso, &v8::Exception::TypeError, e.text());
    }
}

////////////////////////////////////////////////////////////////////////////////
v8::CBK_RET otSimWrapperInterface_js_dispatcher::v8_get_day_of_year7( const v8::ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    if (args.Length() < 0 || args.Length() > 0) { //in/inout arguments
        coid::charstr tmp = "Wrong number of arguments in ";
        tmp << "otSimWrapperInterface.get_day_of_year";
        return v8::throw_js(iso, v8::Exception::SyntaxError, tmp);
    }

    V8_ESCAPABLE_SCOPE(iso, handle_scope__);
    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return V8_RETURN(args, V8_UNDEFINED);

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return V8_RETURN(args, V8_UNDEFINED);

    ::js::interface_wrapper_base<sf::otSimWrapperInterface>* ifc = static_cast<::js::interface_wrapper_base<sf::otSimWrapperInterface>*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    auto R_ = ifc ? ifc->_real() : 0;
    if (!R_) {
        coid::charstr tmp = "Null interface object in ";
        tmp << "otSimWrapperInterface.get_day_of_year";
        return v8::throw_js(iso, &v8::Exception::ReferenceError, tmp);
    }

    v8::Context::Scope context_scope(ifc->context(iso));

    try {
    THREAD_SINGLETON(v8_streamer_context).reset();

    //stream the arguments in

    //invoke
    int _rval_ = R_->get_day_of_year();

    //stream out
    v8::Handle<v8::Value> r__;
    static_assert( CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'" );
    r__ = to_v8(_rval_);

#ifdef V8_MAJOR_VERSION
    args.GetReturnValue().Set(r__);
#else
    return V8_ESCAPE(handle_scope__, r__);
#endif

    } catch(const coid::exception& e) {
        return v8::throw_js(iso, &v8::Exception::TypeError, e.text());
    }
}


////////////////////////////////////////////////////////////////////////////////
v8::CBK_RET otSimWrapperInterface_js_dispatcher::v8log( const v8::ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    if (args.Length() == 0)
        return V8_RETURN(args, V8_UNDEFINED);

    const void* inst = 0;

    v8::Local<v8::Object> obj__ = args.Holder();
    if (!obj__.IsEmpty() && obj__->InternalFieldCount() > 0) {
        v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
        if (intobj__->IsExternal()) {
            sf::js::otSimWrapperInterface_js_dispatcher* ifc = static_cast<sf::js::otSimWrapperInterface_js_dispatcher*>
                (v8::Handle<v8::External>::Cast(intobj__)->Value());

            inst = ifc;
            if (!ifc)
                return v8::throw_js(iso, &v8::Exception::ReferenceError, "Null interface object in $log");
        }
    }

    V8_ESCAPABLE_SCOPE(iso, handle_scope__);
    v8::String::Utf8Value key(args[0]);

    coid::token tokey(*key, key.length());

    intergen_interface::ifclog_ext(coid::log::none, coid::tokenhash("sf::otSimWrapperInterface"),
        inst, tokey);

    return V8_RETURN(args, V8_UNDEFINED);
}

////////////////////////////////////////////////////////////////////////////////
v8::CBK_RET otSimWrapperInterface_js_dispatcher::v8query_interface( const v8::ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    if (args.Length() < 1)
        return v8::throw_js(iso, &v8::Exception::Error, "Interface creator name missing");

    V8_ESCAPABLE_SCOPE(iso, handle_scope__);
    v8::String::Utf8Value key(args[0]);

    typedef v8::Handle<v8::Value> (*fn_get)(const v8::ARGUMENTS&, interface_context*);
    coid::token tokey(*key, key.length());
    fn_get get = reinterpret_cast<fn_get>(
        coid::interface_register::get_interface_creator(tokey));

    if (!get) {
        coid::charstr tmp = "interface creator ";
        tmp << tokey << " not found";
        return v8::throw_js(iso, v8::Exception::Error, tmp);
    }

    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return V8_RETURN(args, V8_UNDEFINED);

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return V8_RETURN(args, V8_UNDEFINED);

    sf::js::otSimWrapperInterface_js_dispatcher* ifc = static_cast<sf::js::otSimWrapperInterface_js_dispatcher*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    if (!ifc)
        return v8::throw_js(iso, &v8::Exception::ReferenceError, "Null interface object in $query_interface");

#ifdef V8_MAJOR_VERSION
    args.GetReturnValue().Set(get(args, ifc));
#else
    return V8_ESCAPE(handle_scope__, get(args, ifc));
#endif
}

////////////////////////////////////////////////////////////////////////////////
v8::CBK_RET otSimWrapperInterface_js_dispatcher::v8query_interface_global( const v8::ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    if (args.Length() < 1)
        return v8::throw_js(iso, &v8::Exception::Error, "Interface creator name missing");

    V8_ESCAPABLE_SCOPE(iso, handle_scope__);
    v8::String::Utf8Value key(args[0]);

    typedef v8::Handle<v8::Value> (*fn_get)(const v8::ARGUMENTS&, interface_context*);
    coid::token tokey(*key, key.length());
    fn_get get = reinterpret_cast<fn_get>(
        coid::interface_register::get_interface_creator(tokey));

    if (!get) {
        coid::charstr tmp = "interface creator ";
        tmp << tokey << " not found";
        return v8::throw_js(iso, v8::Exception::Error, tmp);
    }

#ifdef V8_MAJOR_VERSION
    args.GetReturnValue().Set(get(args, 0));
#else
    return V8_ESCAPE(handle_scope__, get(args, 0));
#endif
}

////////////////////////////////////////////////////////////////////////////////
v8::CBK_RET otSimWrapperInterface_js_dispatcher::v8rebind_events( const v8::ARGUMENTS& args )
{
    return V8_RETURN(args, V8_UNDEFINED);
}

////////////////////////////////////////////////////////////////////////////////
v8::CBK_RET otSimWrapperInterface_js_dispatcher::v8current_global( const v8::ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    V8_ESCAPABLE_SCOPE(iso, handle_scope__);
    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return V8_RETURN(args, V8_UNDEFINED);

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return V8_RETURN(args, V8_UNDEFINED);

    sf::js::otSimWrapperInterface_js_dispatcher* ifc = static_cast<sf::js::otSimWrapperInterface_js_dispatcher*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

#ifdef V8_MAJOR_VERSION
    args.GetReturnValue().Set(ifc->context(iso)->Global()->GetPrototype());
#else
    return V8_ESCAPE(handle_scope__, ifc->context(iso)->Global()->GetPrototype());
#endif
}

////////////////////////////////////////////////////////////////////////////////
v8::Handle<v8::Object> otSimWrapperInterface_js_dispatcher::create_interface_object( v8::Handle<v8::Context> context, bool make_weak )
{
    v8::Isolate* iso = v8::Isolate::GetCurrent();

    static v8::Persistent<v8::ObjectTemplate> _objtempl;
    if (_objtempl.IsEmpty())
    {
        v8::Local<v8::ObjectTemplate> ot = V8_NEWTYPE(iso, ObjectTemplate);
        ot->SetInternalFieldCount(2);    //ptr and class hash id

        ot->Set(v8::symbol("updateSimulation"), V8_NEWTYPE2(iso, FunctionTemplate, &v8_updateSimulation0));
        ot->Set(v8::symbol("updatePhysics"), V8_NEWTYPE2(iso, FunctionTemplate, &v8_updatePhysics1));
        ot->Set(v8::symbol("set_time_of_day"), V8_NEWTYPE2(iso, FunctionTemplate, &v8_set_time_of_day2));
        ot->Set(v8::symbol("set_timeflow_multiplier"), V8_NEWTYPE2(iso, FunctionTemplate, &v8_set_timeflow_multiplier3));
        ot->Set(v8::symbol("set_day_of_year"), V8_NEWTYPE2(iso, FunctionTemplate, &v8_set_day_of_year4));
        ot->Set(v8::symbol("get_time_of_day"), V8_NEWTYPE2(iso, FunctionTemplate, &v8_get_time_of_day5));
        ot->Set(v8::symbol("get_timeflow_multiplier"), V8_NEWTYPE2(iso, FunctionTemplate, &v8_get_timeflow_multiplier6));
        ot->Set(v8::symbol("get_day_of_year"), V8_NEWTYPE2(iso, FunctionTemplate, &v8_get_day_of_year7));

        ot->Set(v8::symbol("$query_interface"), V8_NEWTYPE2(iso, FunctionTemplate, &v8query_interface));
        ot->Set(v8::symbol("$rebind_events"), V8_NEWTYPE2(iso, FunctionTemplate, &v8rebind_events));
        ot->Set(v8::symbol("$ctx"), V8_NEWTYPE2(iso, FunctionTemplate, &v8current_global));
        ot->Set(v8::symbol("$log"), V8_NEWTYPE2(iso, FunctionTemplate, &v8log));

        V8_PERSISTENT(iso, _objtempl, ot);
    }

    v8::Context::Scope ctxscope(context);
    v8::Local<v8::Object> obj = V8_LOCAL(iso, _objtempl)->NewInstance();

    v8::Handle<v8::External> map_ptr = V8_NEWTYPE2(iso, External, this);
    obj->SetInternalField(0, map_ptr);
    v8::Handle<v8::External> hash_ptr = V8_NEWTYPE2(iso, External, (void*)ints(2851289527));
    obj->SetInternalField(1, hash_ptr);

    if (make_weak) {
        V8_PERSISTENT(iso, _object, obj);

#ifdef V8_MAJOR_VERSION
        void* p = this;
        _object.SetWeak(&p, _js_release_callback, v8::WeakCallbackType::kParameter);
        //_context.SetWeak();
#else
        _object.MakeWeak(this, _js_release_callback);
        //_context.MakeWeak(0, _js_release_callback);
#endif
        add_refcount();
    }

    return obj;
}

////////////////////////////////////////////////////////////////////////////////
v8::Handle<v8::Script> otSimWrapperInterface_js_dispatcher::load_script( const coid::token& script, const coid::token& fname )
{
    v8::Local<v8::String> scriptv8 = v8::string_utf8(script);

    // set up an error handler to catch any exceptions the script might throw.
    v8::TryCatch trycatch__;

    v8::Handle<v8::Script> compiled_script = v8::Script::Compile(scriptv8, v8::symbol(fname));
    if (trycatch__.HasCaught())
        script_handle::throw_js_error(trycatch__, "sf::js::otSimWrapperInterface::load_script(): ");

    compiled_script->Run();
    if (trycatch__.HasCaught())
        script_handle::throw_js_error(trycatch__, "sf::js::otSimWrapperInterface::load_script(): ");

    return compiled_script;
}

// --- creators ---

////////////////////////////////////////////////////////////////////////////////
iref<otSimWrapperInterface_js_dispatcher> otSimWrapperInterface_js_dispatcher::get( const script_handle& script, const coid::token& bindname, v8::Handle<v8::Context>* ctx )
{
    v8::Isolate* iso = script.has_context()
        ? script.context()->GetIsolate()
        : v8::Isolate::GetCurrent();

    V8_ESCAPABLE_SCOPE(iso, handle_scope__);
    v8::Handle<v8::Context> context;

    // create interface object
    iref<otSimWrapperInterface_js_dispatcher> ifc = sf::otSimWrapperInterface::get(new otSimWrapperInterface_js_dispatcher);
    if (!ifc)
        throw coid::exception() << "failed to create interface object";

    // check if an external context provider is required
    if (script.is_path()) {
        coid::token path = script.str();
        path.cut_right('?', coid::token::cut_trait_remove_sep_default_empty());

        bool ispage = path.begins_with("http://") || path.begins_with("https://") || path.ends_with(".html");
        bool isscript = path.ends_with(".js");

        if (ispage && !isscript) {
            typedef v8::Handle<v8::Context> (*fn_getctx)(const coid::token&, policy_intrusive_base*);

            fn_getctx ctxgetter = reinterpret_cast<fn_getctx>(
                    coid::interface_register::get_interface_creator("~html@system_context_getter2"));

            if (!ctxgetter)
                throw coid::exception() << "unable to acquire the system context creator interface";

            context = ctxgetter(script.str(), ifc.get());
            if (context.IsEmpty())
                throw coid::exception() << "unable to create context";
        }
    }

    bool extctx = !context.IsEmpty();

    if (!extctx) {
        if (script.has_context())
            context = script.context();
        else
            context = V8_NEWTYPE(iso, Context);
    }

    //set early here as sometimes the invoked creator methods want to access it
    if (ctx)
        *ctx = V8_ESCAPE(handle_scope__, context);

    v8::Context::Scope context_scope(context);
    //V8_PERSISTENT(iso, ifc->_context, context);

    if (!extctx && !script.is_context())
    {
        if (!script.has_context()) {
            context->Global()->Set(v8::symbol("$include"), V8_NEWTYPE2(iso, FunctionTemplate, &script_handle::js_include)->GetFunction());
            context->Global()->Set(v8::symbol("$query_interface"), V8_NEWTYPE2(iso, FunctionTemplate, &otSimWrapperInterface_js_dispatcher::v8query_interface_global)->GetFunction());
            context->Global()->Set(v8::symbol("$log"), V8_NEWTYPE2(iso, FunctionTemplate, &otSimWrapperInterface_js_dispatcher::v8log)->GetFunction());
        }

        coid::token script_tok;
        coid::charstr script_tmp;
        if (script.is_path()) {
            coid::bifstream bif (script.str());
            if (!bif.is_open())
                throw coid::exception() << script.str() << " not found";

            script_tmp = script.prefix();

            coid::binstreambuf buf;
            buf.swap(script_tmp);
            buf.transfer_from(bif);
            buf.swap(script_tmp);

            script_tok = script_tmp;
        }
        else if (script.prefix()) {
            script_tmp << script.prefix() << script.str();
            script_tok = script_tmp;
        }
        else {
            script_tok = script.str();
        }

        V8_PERSISTENT(iso, ifc->_object, ifc->create_interface_object(context, false));
        if (bindname)
            context->Global()->Set(v8::symbol(bindname), V8_LOCAL(iso, ifc->_object));

        v8::Handle<v8::Script> compiled_script = load_script(script_tok, script.url());

        //V8_PERSISTENT(iso, ifc->_script, compiled_script);
    }
    else {
        V8_PERSISTENT(iso, ifc->_object, ifc->create_interface_object(context, false));

        if (bindname)
            context->Global()->Set(v8::symbol(bindname), V8_LOCAL(iso, ifc->_object));
    }

    return ifc;
}

////////////////////////////////////////////////////////////////////////////////
///Creator methods for access from JS
v8::Handle<v8::Value> otSimWrapperInterface_js_dispatcher::v8creator_get0( const v8::ARGUMENTS& args, interface_context* ifc )
{
    v8::Isolate* iso = args.GetIsolate();

    if (args.Length() < 1+0 || args.Length() > 1+0) { //fnc name + in/inout arguments
        coid::charstr tmp = "Wrong number of arguments in ";
        tmp << "get";
        v8::throw_js(iso, &v8::Exception::Error, tmp);
        return V8_UNDEFINED;
    }

    V8_ESCAPABLE_SCOPE(iso, handle_scope__);
    v8::Local<v8::Object> obj__ = args.Holder();

    //sf::js::otSimWrapperInterface_js_dispatcher* ifc = static_cast<sf::js::otSimWrapperInterface_js_dispatcher*>
    //    (v8::Handle<v8::External>::Cast(obj__->GetInternalField(0))->Value());

    v8::Local<v8::Context> ctx = ifc && !ifc->_object.IsEmpty()
        ? ifc->context(iso)
        : V8_CUR_CONTEXT(iso);
    v8::Context::Scope context_scope(ctx);

    //stream the arguments in
    THREAD_SINGLETON(v8_streamer_context).reset();

    //invoke
    iref<otSimWrapperInterface_js_dispatcher> nifc = sf::otSimWrapperInterface::get(new otSimWrapperInterface_js_dispatcher);
    //if (nifc)
    //    V8_PERSISTENT(iso, nifc->_context, ctx);//ifc->_context);

    //stream out
    v8::Handle<v8::Value> r__ = nifc ? v8::Handle<v8::Value>(nifc->create_interface_object(ctx, true)) : V8_NULL(iso);

    return V8_ESCAPE(handle_scope__, r__);
}

////////////////////////////////////////////////////////////////////////////////
///Create JS wrapper from an existing interface object
v8::Handle<v8::Value> create_wrapper_otSimWrapperInterface( ::sf::otSimWrapperInterface* orig, v8::Handle<v8::Context> context )
{
    v8::Isolate* iso = v8::Isolate::GetCurrent();

    // check that the orig points to an object
    if (!orig) return V8_NULL(iso);

    if (context.IsEmpty()) {
        context = V8_CUR_CONTEXT(iso);
    }

    v8::Context::Scope context_scope(context);
    V8_ESCAPABLE_SCOPE(iso, scope);

    iref<sf::js::otSimWrapperInterface_js_dispatcher> ifc;
    v8::Handle<v8::Object> obj;

    if (orig->intergen_backend() == intergen_interface::IFC_BACKEND_JS)
        obj = V8_LOCAL(iso, static_cast<otSimWrapperInterface_js_dispatcher*>(orig)->_object);

    if (obj.IsEmpty()) {
        // create interface object
        ifc.create(new sf::js::otSimWrapperInterface_js_dispatcher(static_cast<::sf::otSimWrapperInterface*>(orig)));

        obj = ifc->create_interface_object(context, true);
    }

    return V8_ESCAPE(scope, obj);
}

////////////////////////////////////////////////////////////////////////////////
///Create JS interface from a host
static iref<sf::js::otSimWrapperInterface_js_dispatcher> create_maker_otSimWrapperInterface( policy_intrusive_base* host, v8::Handle<v8::Context> context )
{
    v8::Isolate* iso = context.IsEmpty() ? v8::Isolate::GetCurrent() : context->GetIsolate();
    if (context.IsEmpty())
        context = V8_CUR_CONTEXT(iso);

    // check that the orig points to an object
    if (!host)
        return 0;

    v8::Context::Scope context_scope(context);
    V8_ESCAPABLE_SCOPE(iso, scope);

    // create interface object
    iref<sf::js::otSimWrapperInterface_js_dispatcher> ifc;

    ifc.create(new sf::js::otSimWrapperInterface_js_dispatcher);
    ifc->set_host(host);

    ifc->create_interface_object(context, false);

    return ifc;
}

////////////////////////////////////////////////////////////////////////////////
static void register_binders_for_otSimWrapperInterface( bool on )
{
    //c++ creator of JS interface object
    interface_register::register_interface_creator(
        "sf::otSimWrapperInterface.get@creator.js",
        on ? (void*)&otSimWrapperInterface_js_dispatcher::get : nullptr);

    //creator from script
    interface_register::register_interface_creator(
        "sf::js::otSimWrapperInterface.get",
        on ? (void*)&otSimWrapperInterface_js_dispatcher::v8creator_get0 : nullptr);

    //wrapper interface creator from existing c++ interface
    interface_register::register_interface_creator(
        "sf::otSimWrapperInterface@wrapper.js",
        on ? (void*)&create_wrapper_otSimWrapperInterface : nullptr);

    //js interface creator from host
    interface_register::register_interface_creator(
        "sf::otSimWrapperInterface@maker.js",
        on ? (void*)&create_maker_otSimWrapperInterface : nullptr);        
}

//auto-register the bind function
LOCAL_SINGLETON_DEF(ifc_autoregger) otSimWrapperInterface_autoregger = new ifc_autoregger(&register_binders_for_otSimWrapperInterface);


void* force_register_otSimWrapperInterface() {
    LOCAL_SINGLETON_DEF(ifc_autoregger) autoregger = new ifc_autoregger(&register_binders_for_otSimWrapperInterface);
    return autoregger.get();
}

} //namespace js
} //namespace sf

